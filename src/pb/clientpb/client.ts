/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.6
 * source: clientpb/client.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../commonpb/common";
import * as pb_1 from "google-protobuf";
export namespace clientpb {
    export enum OutputFormat {
        SHARED_LIB = 0,
        SHELLCODE = 1,
        EXECUTABLE = 2,
        SERVICE = 3
    }
    export enum StageProtocol {
        TCP = 0,
        HTTP = 1,
        HTTPS = 2
    }
    export enum LootType {
        LOOT_FILE = 0,
        LOOT_CREDENTIAL = 1
    }
    export enum CredentialType {
        NO_CREDENTIAL = 0,
        USER_PASSWORD = 1,
        API_KEY = 2,
        FILE = 3
    }
    export enum FileType {
        NO_FILE = 0,
        BINARY = 1,
        TEXT = 2
    }
    export enum ShellcodeEncoder {
        SHIKATA_GA_NAI = 0
    }
    export class Version extends pb_1.Message {
        constructor(data?: any[] | {
            Major?: number;
            Minor?: number;
            Patch?: number;
            Commit?: string;
            Dirty?: boolean;
            CompiledAt?: number;
            OS?: string;
            Arch?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Major" in data && data.Major != undefined) {
                    this.Major = data.Major;
                }
                if ("Minor" in data && data.Minor != undefined) {
                    this.Minor = data.Minor;
                }
                if ("Patch" in data && data.Patch != undefined) {
                    this.Patch = data.Patch;
                }
                if ("Commit" in data && data.Commit != undefined) {
                    this.Commit = data.Commit;
                }
                if ("Dirty" in data && data.Dirty != undefined) {
                    this.Dirty = data.Dirty;
                }
                if ("CompiledAt" in data && data.CompiledAt != undefined) {
                    this.CompiledAt = data.CompiledAt;
                }
                if ("OS" in data && data.OS != undefined) {
                    this.OS = data.OS;
                }
                if ("Arch" in data && data.Arch != undefined) {
                    this.Arch = data.Arch;
                }
            }
        }
        get Major() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set Major(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Minor() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set Minor(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get Patch() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set Patch(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Commit() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set Commit(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Dirty() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set Dirty(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get CompiledAt() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set CompiledAt(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get OS() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set OS(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get Arch() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set Arch(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            Major?: number;
            Minor?: number;
            Patch?: number;
            Commit?: string;
            Dirty?: boolean;
            CompiledAt?: number;
            OS?: string;
            Arch?: string;
        }) {
            const message = new Version({});
            if (data.Major != null) {
                message.Major = data.Major;
            }
            if (data.Minor != null) {
                message.Minor = data.Minor;
            }
            if (data.Patch != null) {
                message.Patch = data.Patch;
            }
            if (data.Commit != null) {
                message.Commit = data.Commit;
            }
            if (data.Dirty != null) {
                message.Dirty = data.Dirty;
            }
            if (data.CompiledAt != null) {
                message.CompiledAt = data.CompiledAt;
            }
            if (data.OS != null) {
                message.OS = data.OS;
            }
            if (data.Arch != null) {
                message.Arch = data.Arch;
            }
            return message;
        }
        toObject() {
            const data: {
                Major?: number;
                Minor?: number;
                Patch?: number;
                Commit?: string;
                Dirty?: boolean;
                CompiledAt?: number;
                OS?: string;
                Arch?: string;
            } = {};
            if (this.Major != null) {
                data.Major = this.Major;
            }
            if (this.Minor != null) {
                data.Minor = this.Minor;
            }
            if (this.Patch != null) {
                data.Patch = this.Patch;
            }
            if (this.Commit != null) {
                data.Commit = this.Commit;
            }
            if (this.Dirty != null) {
                data.Dirty = this.Dirty;
            }
            if (this.CompiledAt != null) {
                data.CompiledAt = this.CompiledAt;
            }
            if (this.OS != null) {
                data.OS = this.OS;
            }
            if (this.Arch != null) {
                data.Arch = this.Arch;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Major !== undefined)
                writer.writeInt32(1, this.Major);
            if (this.Minor !== undefined)
                writer.writeInt32(2, this.Minor);
            if (this.Patch !== undefined)
                writer.writeInt32(3, this.Patch);
            if (typeof this.Commit === "string" && this.Commit.length)
                writer.writeString(4, this.Commit);
            if (this.Dirty !== undefined)
                writer.writeBool(5, this.Dirty);
            if (this.CompiledAt !== undefined)
                writer.writeInt64(6, this.CompiledAt);
            if (typeof this.OS === "string" && this.OS.length)
                writer.writeString(7, this.OS);
            if (typeof this.Arch === "string" && this.Arch.length)
                writer.writeString(8, this.Arch);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Version {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Version();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Major = reader.readInt32();
                        break;
                    case 2:
                        message.Minor = reader.readInt32();
                        break;
                    case 3:
                        message.Patch = reader.readInt32();
                        break;
                    case 4:
                        message.Commit = reader.readString();
                        break;
                    case 5:
                        message.Dirty = reader.readBool();
                        break;
                    case 6:
                        message.CompiledAt = reader.readInt64();
                        break;
                    case 7:
                        message.OS = reader.readString();
                        break;
                    case 8:
                        message.Arch = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Version {
            return Version.deserialize(bytes);
        }
    }
    export class Session extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: string;
            Name?: string;
            Hostname?: string;
            UUID?: string;
            Username?: string;
            UID?: string;
            GID?: string;
            OS?: string;
            Arch?: string;
            Transport?: string;
            RemoteAddress?: string;
            PID?: number;
            Filename?: string;
            LastCheckin?: number;
            ActiveC2?: string;
            Version?: string;
            Evasion?: boolean;
            IsDead?: boolean;
            ReconnectInterval?: number;
            ProxyURL?: string;
            Burned?: boolean;
            Extensions?: string[];
            PeerID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [23], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Hostname" in data && data.Hostname != undefined) {
                    this.Hostname = data.Hostname;
                }
                if ("UUID" in data && data.UUID != undefined) {
                    this.UUID = data.UUID;
                }
                if ("Username" in data && data.Username != undefined) {
                    this.Username = data.Username;
                }
                if ("UID" in data && data.UID != undefined) {
                    this.UID = data.UID;
                }
                if ("GID" in data && data.GID != undefined) {
                    this.GID = data.GID;
                }
                if ("OS" in data && data.OS != undefined) {
                    this.OS = data.OS;
                }
                if ("Arch" in data && data.Arch != undefined) {
                    this.Arch = data.Arch;
                }
                if ("Transport" in data && data.Transport != undefined) {
                    this.Transport = data.Transport;
                }
                if ("RemoteAddress" in data && data.RemoteAddress != undefined) {
                    this.RemoteAddress = data.RemoteAddress;
                }
                if ("PID" in data && data.PID != undefined) {
                    this.PID = data.PID;
                }
                if ("Filename" in data && data.Filename != undefined) {
                    this.Filename = data.Filename;
                }
                if ("LastCheckin" in data && data.LastCheckin != undefined) {
                    this.LastCheckin = data.LastCheckin;
                }
                if ("ActiveC2" in data && data.ActiveC2 != undefined) {
                    this.ActiveC2 = data.ActiveC2;
                }
                if ("Version" in data && data.Version != undefined) {
                    this.Version = data.Version;
                }
                if ("Evasion" in data && data.Evasion != undefined) {
                    this.Evasion = data.Evasion;
                }
                if ("IsDead" in data && data.IsDead != undefined) {
                    this.IsDead = data.IsDead;
                }
                if ("ReconnectInterval" in data && data.ReconnectInterval != undefined) {
                    this.ReconnectInterval = data.ReconnectInterval;
                }
                if ("ProxyURL" in data && data.ProxyURL != undefined) {
                    this.ProxyURL = data.ProxyURL;
                }
                if ("Burned" in data && data.Burned != undefined) {
                    this.Burned = data.Burned;
                }
                if ("Extensions" in data && data.Extensions != undefined) {
                    this.Extensions = data.Extensions;
                }
                if ("PeerID" in data && data.PeerID != undefined) {
                    this.PeerID = data.PeerID;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Hostname() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Hostname(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get UUID() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set UUID(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Username() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set Username(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get UID() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set UID(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get GID() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set GID(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get OS() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set OS(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get Arch() {
            return pb_1.Message.getField(this, 9) as string;
        }
        set Arch(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get Transport() {
            return pb_1.Message.getField(this, 10) as string;
        }
        set Transport(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get RemoteAddress() {
            return pb_1.Message.getField(this, 11) as string;
        }
        set RemoteAddress(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        get PID() {
            return pb_1.Message.getField(this, 12) as number;
        }
        set PID(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get Filename() {
            return pb_1.Message.getField(this, 13) as string;
        }
        set Filename(value: string) {
            pb_1.Message.setField(this, 13, value);
        }
        get LastCheckin() {
            return pb_1.Message.getField(this, 14) as number;
        }
        set LastCheckin(value: number) {
            pb_1.Message.setField(this, 14, value);
        }
        get ActiveC2() {
            return pb_1.Message.getField(this, 15) as string;
        }
        set ActiveC2(value: string) {
            pb_1.Message.setField(this, 15, value);
        }
        get Version() {
            return pb_1.Message.getField(this, 16) as string;
        }
        set Version(value: string) {
            pb_1.Message.setField(this, 16, value);
        }
        get Evasion() {
            return pb_1.Message.getField(this, 17) as boolean;
        }
        set Evasion(value: boolean) {
            pb_1.Message.setField(this, 17, value);
        }
        get IsDead() {
            return pb_1.Message.getField(this, 18) as boolean;
        }
        set IsDead(value: boolean) {
            pb_1.Message.setField(this, 18, value);
        }
        get ReconnectInterval() {
            return pb_1.Message.getField(this, 19) as number;
        }
        set ReconnectInterval(value: number) {
            pb_1.Message.setField(this, 19, value);
        }
        get ProxyURL() {
            return pb_1.Message.getField(this, 20) as string;
        }
        set ProxyURL(value: string) {
            pb_1.Message.setField(this, 20, value);
        }
        get Burned() {
            return pb_1.Message.getField(this, 22) as boolean;
        }
        set Burned(value: boolean) {
            pb_1.Message.setField(this, 22, value);
        }
        get Extensions() {
            return pb_1.Message.getField(this, 23) as string[];
        }
        set Extensions(value: string[]) {
            pb_1.Message.setField(this, 23, value);
        }
        get PeerID() {
            return pb_1.Message.getField(this, 25) as number;
        }
        set PeerID(value: number) {
            pb_1.Message.setField(this, 25, value);
        }
        static fromObject(data: {
            ID?: string;
            Name?: string;
            Hostname?: string;
            UUID?: string;
            Username?: string;
            UID?: string;
            GID?: string;
            OS?: string;
            Arch?: string;
            Transport?: string;
            RemoteAddress?: string;
            PID?: number;
            Filename?: string;
            LastCheckin?: number;
            ActiveC2?: string;
            Version?: string;
            Evasion?: boolean;
            IsDead?: boolean;
            ReconnectInterval?: number;
            ProxyURL?: string;
            Burned?: boolean;
            Extensions?: string[];
            PeerID?: number;
        }) {
            const message = new Session({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Hostname != null) {
                message.Hostname = data.Hostname;
            }
            if (data.UUID != null) {
                message.UUID = data.UUID;
            }
            if (data.Username != null) {
                message.Username = data.Username;
            }
            if (data.UID != null) {
                message.UID = data.UID;
            }
            if (data.GID != null) {
                message.GID = data.GID;
            }
            if (data.OS != null) {
                message.OS = data.OS;
            }
            if (data.Arch != null) {
                message.Arch = data.Arch;
            }
            if (data.Transport != null) {
                message.Transport = data.Transport;
            }
            if (data.RemoteAddress != null) {
                message.RemoteAddress = data.RemoteAddress;
            }
            if (data.PID != null) {
                message.PID = data.PID;
            }
            if (data.Filename != null) {
                message.Filename = data.Filename;
            }
            if (data.LastCheckin != null) {
                message.LastCheckin = data.LastCheckin;
            }
            if (data.ActiveC2 != null) {
                message.ActiveC2 = data.ActiveC2;
            }
            if (data.Version != null) {
                message.Version = data.Version;
            }
            if (data.Evasion != null) {
                message.Evasion = data.Evasion;
            }
            if (data.IsDead != null) {
                message.IsDead = data.IsDead;
            }
            if (data.ReconnectInterval != null) {
                message.ReconnectInterval = data.ReconnectInterval;
            }
            if (data.ProxyURL != null) {
                message.ProxyURL = data.ProxyURL;
            }
            if (data.Burned != null) {
                message.Burned = data.Burned;
            }
            if (data.Extensions != null) {
                message.Extensions = data.Extensions;
            }
            if (data.PeerID != null) {
                message.PeerID = data.PeerID;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: string;
                Name?: string;
                Hostname?: string;
                UUID?: string;
                Username?: string;
                UID?: string;
                GID?: string;
                OS?: string;
                Arch?: string;
                Transport?: string;
                RemoteAddress?: string;
                PID?: number;
                Filename?: string;
                LastCheckin?: number;
                ActiveC2?: string;
                Version?: string;
                Evasion?: boolean;
                IsDead?: boolean;
                ReconnectInterval?: number;
                ProxyURL?: string;
                Burned?: boolean;
                Extensions?: string[];
                PeerID?: number;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Hostname != null) {
                data.Hostname = this.Hostname;
            }
            if (this.UUID != null) {
                data.UUID = this.UUID;
            }
            if (this.Username != null) {
                data.Username = this.Username;
            }
            if (this.UID != null) {
                data.UID = this.UID;
            }
            if (this.GID != null) {
                data.GID = this.GID;
            }
            if (this.OS != null) {
                data.OS = this.OS;
            }
            if (this.Arch != null) {
                data.Arch = this.Arch;
            }
            if (this.Transport != null) {
                data.Transport = this.Transport;
            }
            if (this.RemoteAddress != null) {
                data.RemoteAddress = this.RemoteAddress;
            }
            if (this.PID != null) {
                data.PID = this.PID;
            }
            if (this.Filename != null) {
                data.Filename = this.Filename;
            }
            if (this.LastCheckin != null) {
                data.LastCheckin = this.LastCheckin;
            }
            if (this.ActiveC2 != null) {
                data.ActiveC2 = this.ActiveC2;
            }
            if (this.Version != null) {
                data.Version = this.Version;
            }
            if (this.Evasion != null) {
                data.Evasion = this.Evasion;
            }
            if (this.IsDead != null) {
                data.IsDead = this.IsDead;
            }
            if (this.ReconnectInterval != null) {
                data.ReconnectInterval = this.ReconnectInterval;
            }
            if (this.ProxyURL != null) {
                data.ProxyURL = this.ProxyURL;
            }
            if (this.Burned != null) {
                data.Burned = this.Burned;
            }
            if (this.Extensions != null) {
                data.Extensions = this.Extensions;
            }
            if (this.PeerID != null) {
                data.PeerID = this.PeerID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ID === "string" && this.ID.length)
                writer.writeString(1, this.ID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(2, this.Name);
            if (typeof this.Hostname === "string" && this.Hostname.length)
                writer.writeString(3, this.Hostname);
            if (typeof this.UUID === "string" && this.UUID.length)
                writer.writeString(4, this.UUID);
            if (typeof this.Username === "string" && this.Username.length)
                writer.writeString(5, this.Username);
            if (typeof this.UID === "string" && this.UID.length)
                writer.writeString(6, this.UID);
            if (typeof this.GID === "string" && this.GID.length)
                writer.writeString(7, this.GID);
            if (typeof this.OS === "string" && this.OS.length)
                writer.writeString(8, this.OS);
            if (typeof this.Arch === "string" && this.Arch.length)
                writer.writeString(9, this.Arch);
            if (typeof this.Transport === "string" && this.Transport.length)
                writer.writeString(10, this.Transport);
            if (typeof this.RemoteAddress === "string" && this.RemoteAddress.length)
                writer.writeString(11, this.RemoteAddress);
            if (this.PID !== undefined)
                writer.writeInt32(12, this.PID);
            if (typeof this.Filename === "string" && this.Filename.length)
                writer.writeString(13, this.Filename);
            if (this.LastCheckin !== undefined)
                writer.writeInt64(14, this.LastCheckin);
            if (typeof this.ActiveC2 === "string" && this.ActiveC2.length)
                writer.writeString(15, this.ActiveC2);
            if (typeof this.Version === "string" && this.Version.length)
                writer.writeString(16, this.Version);
            if (this.Evasion !== undefined)
                writer.writeBool(17, this.Evasion);
            if (this.IsDead !== undefined)
                writer.writeBool(18, this.IsDead);
            if (this.ReconnectInterval !== undefined)
                writer.writeInt64(19, this.ReconnectInterval);
            if (typeof this.ProxyURL === "string" && this.ProxyURL.length)
                writer.writeString(20, this.ProxyURL);
            if (this.Burned !== undefined)
                writer.writeBool(22, this.Burned);
            if (this.Extensions !== undefined)
                writer.writeRepeatedString(23, this.Extensions);
            if (this.PeerID !== undefined)
                writer.writeInt64(25, this.PeerID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Session {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Session();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readString();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    case 3:
                        message.Hostname = reader.readString();
                        break;
                    case 4:
                        message.UUID = reader.readString();
                        break;
                    case 5:
                        message.Username = reader.readString();
                        break;
                    case 6:
                        message.UID = reader.readString();
                        break;
                    case 7:
                        message.GID = reader.readString();
                        break;
                    case 8:
                        message.OS = reader.readString();
                        break;
                    case 9:
                        message.Arch = reader.readString();
                        break;
                    case 10:
                        message.Transport = reader.readString();
                        break;
                    case 11:
                        message.RemoteAddress = reader.readString();
                        break;
                    case 12:
                        message.PID = reader.readInt32();
                        break;
                    case 13:
                        message.Filename = reader.readString();
                        break;
                    case 14:
                        message.LastCheckin = reader.readInt64();
                        break;
                    case 15:
                        message.ActiveC2 = reader.readString();
                        break;
                    case 16:
                        message.Version = reader.readString();
                        break;
                    case 17:
                        message.Evasion = reader.readBool();
                        break;
                    case 18:
                        message.IsDead = reader.readBool();
                        break;
                    case 19:
                        message.ReconnectInterval = reader.readInt64();
                        break;
                    case 20:
                        message.ProxyURL = reader.readString();
                        break;
                    case 22:
                        message.Burned = reader.readBool();
                        break;
                    case 23:
                        pb_1.Message.addToRepeatedField(message, 23, reader.readString());
                        break;
                    case 25:
                        message.PeerID = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Session {
            return Session.deserialize(bytes);
        }
    }
    export class Beacon extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: string;
            Name?: string;
            Hostname?: string;
            UUID?: string;
            Username?: string;
            UID?: string;
            GID?: string;
            OS?: string;
            Arch?: string;
            Transport?: string;
            RemoteAddress?: string;
            PID?: number;
            Filename?: string;
            LastCheckin?: number;
            ActiveC2?: string;
            Version?: string;
            Evasion?: boolean;
            IsDead?: boolean;
            ProxyURL?: string;
            ReconnectInterval?: number;
            Interval?: number;
            Jitter?: number;
            Burned?: boolean;
            NextCheckin?: number;
            TasksCount?: number;
            TasksCountCompleted?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Hostname" in data && data.Hostname != undefined) {
                    this.Hostname = data.Hostname;
                }
                if ("UUID" in data && data.UUID != undefined) {
                    this.UUID = data.UUID;
                }
                if ("Username" in data && data.Username != undefined) {
                    this.Username = data.Username;
                }
                if ("UID" in data && data.UID != undefined) {
                    this.UID = data.UID;
                }
                if ("GID" in data && data.GID != undefined) {
                    this.GID = data.GID;
                }
                if ("OS" in data && data.OS != undefined) {
                    this.OS = data.OS;
                }
                if ("Arch" in data && data.Arch != undefined) {
                    this.Arch = data.Arch;
                }
                if ("Transport" in data && data.Transport != undefined) {
                    this.Transport = data.Transport;
                }
                if ("RemoteAddress" in data && data.RemoteAddress != undefined) {
                    this.RemoteAddress = data.RemoteAddress;
                }
                if ("PID" in data && data.PID != undefined) {
                    this.PID = data.PID;
                }
                if ("Filename" in data && data.Filename != undefined) {
                    this.Filename = data.Filename;
                }
                if ("LastCheckin" in data && data.LastCheckin != undefined) {
                    this.LastCheckin = data.LastCheckin;
                }
                if ("ActiveC2" in data && data.ActiveC2 != undefined) {
                    this.ActiveC2 = data.ActiveC2;
                }
                if ("Version" in data && data.Version != undefined) {
                    this.Version = data.Version;
                }
                if ("Evasion" in data && data.Evasion != undefined) {
                    this.Evasion = data.Evasion;
                }
                if ("IsDead" in data && data.IsDead != undefined) {
                    this.IsDead = data.IsDead;
                }
                if ("ProxyURL" in data && data.ProxyURL != undefined) {
                    this.ProxyURL = data.ProxyURL;
                }
                if ("ReconnectInterval" in data && data.ReconnectInterval != undefined) {
                    this.ReconnectInterval = data.ReconnectInterval;
                }
                if ("Interval" in data && data.Interval != undefined) {
                    this.Interval = data.Interval;
                }
                if ("Jitter" in data && data.Jitter != undefined) {
                    this.Jitter = data.Jitter;
                }
                if ("Burned" in data && data.Burned != undefined) {
                    this.Burned = data.Burned;
                }
                if ("NextCheckin" in data && data.NextCheckin != undefined) {
                    this.NextCheckin = data.NextCheckin;
                }
                if ("TasksCount" in data && data.TasksCount != undefined) {
                    this.TasksCount = data.TasksCount;
                }
                if ("TasksCountCompleted" in data && data.TasksCountCompleted != undefined) {
                    this.TasksCountCompleted = data.TasksCountCompleted;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Hostname() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Hostname(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get UUID() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set UUID(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Username() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set Username(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get UID() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set UID(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get GID() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set GID(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get OS() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set OS(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get Arch() {
            return pb_1.Message.getField(this, 9) as string;
        }
        set Arch(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get Transport() {
            return pb_1.Message.getField(this, 10) as string;
        }
        set Transport(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get RemoteAddress() {
            return pb_1.Message.getField(this, 11) as string;
        }
        set RemoteAddress(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        get PID() {
            return pb_1.Message.getField(this, 12) as number;
        }
        set PID(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get Filename() {
            return pb_1.Message.getField(this, 13) as string;
        }
        set Filename(value: string) {
            pb_1.Message.setField(this, 13, value);
        }
        get LastCheckin() {
            return pb_1.Message.getField(this, 14) as number;
        }
        set LastCheckin(value: number) {
            pb_1.Message.setField(this, 14, value);
        }
        get ActiveC2() {
            return pb_1.Message.getField(this, 15) as string;
        }
        set ActiveC2(value: string) {
            pb_1.Message.setField(this, 15, value);
        }
        get Version() {
            return pb_1.Message.getField(this, 16) as string;
        }
        set Version(value: string) {
            pb_1.Message.setField(this, 16, value);
        }
        get Evasion() {
            return pb_1.Message.getField(this, 17) as boolean;
        }
        set Evasion(value: boolean) {
            pb_1.Message.setField(this, 17, value);
        }
        get IsDead() {
            return pb_1.Message.getField(this, 18) as boolean;
        }
        set IsDead(value: boolean) {
            pb_1.Message.setField(this, 18, value);
        }
        get ProxyURL() {
            return pb_1.Message.getField(this, 20) as string;
        }
        set ProxyURL(value: string) {
            pb_1.Message.setField(this, 20, value);
        }
        get ReconnectInterval() {
            return pb_1.Message.getField(this, 21) as number;
        }
        set ReconnectInterval(value: number) {
            pb_1.Message.setField(this, 21, value);
        }
        get Interval() {
            return pb_1.Message.getField(this, 22) as number;
        }
        set Interval(value: number) {
            pb_1.Message.setField(this, 22, value);
        }
        get Jitter() {
            return pb_1.Message.getField(this, 23) as number;
        }
        set Jitter(value: number) {
            pb_1.Message.setField(this, 23, value);
        }
        get Burned() {
            return pb_1.Message.getField(this, 24) as boolean;
        }
        set Burned(value: boolean) {
            pb_1.Message.setField(this, 24, value);
        }
        get NextCheckin() {
            return pb_1.Message.getField(this, 25) as number;
        }
        set NextCheckin(value: number) {
            pb_1.Message.setField(this, 25, value);
        }
        get TasksCount() {
            return pb_1.Message.getField(this, 26) as number;
        }
        set TasksCount(value: number) {
            pb_1.Message.setField(this, 26, value);
        }
        get TasksCountCompleted() {
            return pb_1.Message.getField(this, 27) as number;
        }
        set TasksCountCompleted(value: number) {
            pb_1.Message.setField(this, 27, value);
        }
        static fromObject(data: {
            ID?: string;
            Name?: string;
            Hostname?: string;
            UUID?: string;
            Username?: string;
            UID?: string;
            GID?: string;
            OS?: string;
            Arch?: string;
            Transport?: string;
            RemoteAddress?: string;
            PID?: number;
            Filename?: string;
            LastCheckin?: number;
            ActiveC2?: string;
            Version?: string;
            Evasion?: boolean;
            IsDead?: boolean;
            ProxyURL?: string;
            ReconnectInterval?: number;
            Interval?: number;
            Jitter?: number;
            Burned?: boolean;
            NextCheckin?: number;
            TasksCount?: number;
            TasksCountCompleted?: number;
        }) {
            const message = new Beacon({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Hostname != null) {
                message.Hostname = data.Hostname;
            }
            if (data.UUID != null) {
                message.UUID = data.UUID;
            }
            if (data.Username != null) {
                message.Username = data.Username;
            }
            if (data.UID != null) {
                message.UID = data.UID;
            }
            if (data.GID != null) {
                message.GID = data.GID;
            }
            if (data.OS != null) {
                message.OS = data.OS;
            }
            if (data.Arch != null) {
                message.Arch = data.Arch;
            }
            if (data.Transport != null) {
                message.Transport = data.Transport;
            }
            if (data.RemoteAddress != null) {
                message.RemoteAddress = data.RemoteAddress;
            }
            if (data.PID != null) {
                message.PID = data.PID;
            }
            if (data.Filename != null) {
                message.Filename = data.Filename;
            }
            if (data.LastCheckin != null) {
                message.LastCheckin = data.LastCheckin;
            }
            if (data.ActiveC2 != null) {
                message.ActiveC2 = data.ActiveC2;
            }
            if (data.Version != null) {
                message.Version = data.Version;
            }
            if (data.Evasion != null) {
                message.Evasion = data.Evasion;
            }
            if (data.IsDead != null) {
                message.IsDead = data.IsDead;
            }
            if (data.ProxyURL != null) {
                message.ProxyURL = data.ProxyURL;
            }
            if (data.ReconnectInterval != null) {
                message.ReconnectInterval = data.ReconnectInterval;
            }
            if (data.Interval != null) {
                message.Interval = data.Interval;
            }
            if (data.Jitter != null) {
                message.Jitter = data.Jitter;
            }
            if (data.Burned != null) {
                message.Burned = data.Burned;
            }
            if (data.NextCheckin != null) {
                message.NextCheckin = data.NextCheckin;
            }
            if (data.TasksCount != null) {
                message.TasksCount = data.TasksCount;
            }
            if (data.TasksCountCompleted != null) {
                message.TasksCountCompleted = data.TasksCountCompleted;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: string;
                Name?: string;
                Hostname?: string;
                UUID?: string;
                Username?: string;
                UID?: string;
                GID?: string;
                OS?: string;
                Arch?: string;
                Transport?: string;
                RemoteAddress?: string;
                PID?: number;
                Filename?: string;
                LastCheckin?: number;
                ActiveC2?: string;
                Version?: string;
                Evasion?: boolean;
                IsDead?: boolean;
                ProxyURL?: string;
                ReconnectInterval?: number;
                Interval?: number;
                Jitter?: number;
                Burned?: boolean;
                NextCheckin?: number;
                TasksCount?: number;
                TasksCountCompleted?: number;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Hostname != null) {
                data.Hostname = this.Hostname;
            }
            if (this.UUID != null) {
                data.UUID = this.UUID;
            }
            if (this.Username != null) {
                data.Username = this.Username;
            }
            if (this.UID != null) {
                data.UID = this.UID;
            }
            if (this.GID != null) {
                data.GID = this.GID;
            }
            if (this.OS != null) {
                data.OS = this.OS;
            }
            if (this.Arch != null) {
                data.Arch = this.Arch;
            }
            if (this.Transport != null) {
                data.Transport = this.Transport;
            }
            if (this.RemoteAddress != null) {
                data.RemoteAddress = this.RemoteAddress;
            }
            if (this.PID != null) {
                data.PID = this.PID;
            }
            if (this.Filename != null) {
                data.Filename = this.Filename;
            }
            if (this.LastCheckin != null) {
                data.LastCheckin = this.LastCheckin;
            }
            if (this.ActiveC2 != null) {
                data.ActiveC2 = this.ActiveC2;
            }
            if (this.Version != null) {
                data.Version = this.Version;
            }
            if (this.Evasion != null) {
                data.Evasion = this.Evasion;
            }
            if (this.IsDead != null) {
                data.IsDead = this.IsDead;
            }
            if (this.ProxyURL != null) {
                data.ProxyURL = this.ProxyURL;
            }
            if (this.ReconnectInterval != null) {
                data.ReconnectInterval = this.ReconnectInterval;
            }
            if (this.Interval != null) {
                data.Interval = this.Interval;
            }
            if (this.Jitter != null) {
                data.Jitter = this.Jitter;
            }
            if (this.Burned != null) {
                data.Burned = this.Burned;
            }
            if (this.NextCheckin != null) {
                data.NextCheckin = this.NextCheckin;
            }
            if (this.TasksCount != null) {
                data.TasksCount = this.TasksCount;
            }
            if (this.TasksCountCompleted != null) {
                data.TasksCountCompleted = this.TasksCountCompleted;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ID === "string" && this.ID.length)
                writer.writeString(1, this.ID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(2, this.Name);
            if (typeof this.Hostname === "string" && this.Hostname.length)
                writer.writeString(3, this.Hostname);
            if (typeof this.UUID === "string" && this.UUID.length)
                writer.writeString(4, this.UUID);
            if (typeof this.Username === "string" && this.Username.length)
                writer.writeString(5, this.Username);
            if (typeof this.UID === "string" && this.UID.length)
                writer.writeString(6, this.UID);
            if (typeof this.GID === "string" && this.GID.length)
                writer.writeString(7, this.GID);
            if (typeof this.OS === "string" && this.OS.length)
                writer.writeString(8, this.OS);
            if (typeof this.Arch === "string" && this.Arch.length)
                writer.writeString(9, this.Arch);
            if (typeof this.Transport === "string" && this.Transport.length)
                writer.writeString(10, this.Transport);
            if (typeof this.RemoteAddress === "string" && this.RemoteAddress.length)
                writer.writeString(11, this.RemoteAddress);
            if (this.PID !== undefined)
                writer.writeInt32(12, this.PID);
            if (typeof this.Filename === "string" && this.Filename.length)
                writer.writeString(13, this.Filename);
            if (this.LastCheckin !== undefined)
                writer.writeInt64(14, this.LastCheckin);
            if (typeof this.ActiveC2 === "string" && this.ActiveC2.length)
                writer.writeString(15, this.ActiveC2);
            if (typeof this.Version === "string" && this.Version.length)
                writer.writeString(16, this.Version);
            if (this.Evasion !== undefined)
                writer.writeBool(17, this.Evasion);
            if (this.IsDead !== undefined)
                writer.writeBool(18, this.IsDead);
            if (typeof this.ProxyURL === "string" && this.ProxyURL.length)
                writer.writeString(20, this.ProxyURL);
            if (this.ReconnectInterval !== undefined)
                writer.writeInt64(21, this.ReconnectInterval);
            if (this.Interval !== undefined)
                writer.writeInt64(22, this.Interval);
            if (this.Jitter !== undefined)
                writer.writeInt64(23, this.Jitter);
            if (this.Burned !== undefined)
                writer.writeBool(24, this.Burned);
            if (this.NextCheckin !== undefined)
                writer.writeInt64(25, this.NextCheckin);
            if (this.TasksCount !== undefined)
                writer.writeInt64(26, this.TasksCount);
            if (this.TasksCountCompleted !== undefined)
                writer.writeInt64(27, this.TasksCountCompleted);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Beacon {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Beacon();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readString();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    case 3:
                        message.Hostname = reader.readString();
                        break;
                    case 4:
                        message.UUID = reader.readString();
                        break;
                    case 5:
                        message.Username = reader.readString();
                        break;
                    case 6:
                        message.UID = reader.readString();
                        break;
                    case 7:
                        message.GID = reader.readString();
                        break;
                    case 8:
                        message.OS = reader.readString();
                        break;
                    case 9:
                        message.Arch = reader.readString();
                        break;
                    case 10:
                        message.Transport = reader.readString();
                        break;
                    case 11:
                        message.RemoteAddress = reader.readString();
                        break;
                    case 12:
                        message.PID = reader.readInt32();
                        break;
                    case 13:
                        message.Filename = reader.readString();
                        break;
                    case 14:
                        message.LastCheckin = reader.readInt64();
                        break;
                    case 15:
                        message.ActiveC2 = reader.readString();
                        break;
                    case 16:
                        message.Version = reader.readString();
                        break;
                    case 17:
                        message.Evasion = reader.readBool();
                        break;
                    case 18:
                        message.IsDead = reader.readBool();
                        break;
                    case 20:
                        message.ProxyURL = reader.readString();
                        break;
                    case 21:
                        message.ReconnectInterval = reader.readInt64();
                        break;
                    case 22:
                        message.Interval = reader.readInt64();
                        break;
                    case 23:
                        message.Jitter = reader.readInt64();
                        break;
                    case 24:
                        message.Burned = reader.readBool();
                        break;
                    case 25:
                        message.NextCheckin = reader.readInt64();
                        break;
                    case 26:
                        message.TasksCount = reader.readInt64();
                        break;
                    case 27:
                        message.TasksCountCompleted = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Beacon {
            return Beacon.deserialize(bytes);
        }
    }
    export class Beacons extends pb_1.Message {
        constructor(data?: any[] | {
            Beacons?: Beacon[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Beacons" in data && data.Beacons != undefined) {
                    this.Beacons = data.Beacons;
                }
            }
        }
        get Beacons() {
            return pb_1.Message.getRepeatedWrapperField(this, Beacon, 2) as Beacon[];
        }
        set Beacons(value: Beacon[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            Beacons?: ReturnType<typeof Beacon.prototype.toObject>[];
        }) {
            const message = new Beacons({});
            if (data.Beacons != null) {
                message.Beacons = data.Beacons.map(item => Beacon.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Beacons?: ReturnType<typeof Beacon.prototype.toObject>[];
            } = {};
            if (this.Beacons != null) {
                data.Beacons = this.Beacons.map((item: Beacon) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Beacons !== undefined)
                writer.writeRepeatedMessage(2, this.Beacons, (item: Beacon) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Beacons {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Beacons();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        reader.readMessage(message.Beacons, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Beacon.deserialize(reader), Beacon));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Beacons {
            return Beacons.deserialize(bytes);
        }
    }
    export class BeaconTask extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: string;
            BeaconID?: string;
            CreatedAt?: number;
            State?: string;
            SentAt?: number;
            CompletedAt?: number;
            Request?: Uint8Array;
            Response?: Uint8Array;
            Description?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("BeaconID" in data && data.BeaconID != undefined) {
                    this.BeaconID = data.BeaconID;
                }
                if ("CreatedAt" in data && data.CreatedAt != undefined) {
                    this.CreatedAt = data.CreatedAt;
                }
                if ("State" in data && data.State != undefined) {
                    this.State = data.State;
                }
                if ("SentAt" in data && data.SentAt != undefined) {
                    this.SentAt = data.SentAt;
                }
                if ("CompletedAt" in data && data.CompletedAt != undefined) {
                    this.CompletedAt = data.CompletedAt;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
                if ("Response" in data && data.Response != undefined) {
                    this.Response = data.Response;
                }
                if ("Description" in data && data.Description != undefined) {
                    this.Description = data.Description;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get BeaconID() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set BeaconID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get CreatedAt() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set CreatedAt(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get State() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set State(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get SentAt() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set SentAt(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get CompletedAt() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set CompletedAt(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Request() {
            return pb_1.Message.getField(this, 7) as Uint8Array;
        }
        set Request(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get Response() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set Response(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get Description() {
            return pb_1.Message.getField(this, 9) as string;
        }
        set Description(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            ID?: string;
            BeaconID?: string;
            CreatedAt?: number;
            State?: string;
            SentAt?: number;
            CompletedAt?: number;
            Request?: Uint8Array;
            Response?: Uint8Array;
            Description?: string;
        }) {
            const message = new BeaconTask({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.BeaconID != null) {
                message.BeaconID = data.BeaconID;
            }
            if (data.CreatedAt != null) {
                message.CreatedAt = data.CreatedAt;
            }
            if (data.State != null) {
                message.State = data.State;
            }
            if (data.SentAt != null) {
                message.SentAt = data.SentAt;
            }
            if (data.CompletedAt != null) {
                message.CompletedAt = data.CompletedAt;
            }
            if (data.Request != null) {
                message.Request = data.Request;
            }
            if (data.Response != null) {
                message.Response = data.Response;
            }
            if (data.Description != null) {
                message.Description = data.Description;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: string;
                BeaconID?: string;
                CreatedAt?: number;
                State?: string;
                SentAt?: number;
                CompletedAt?: number;
                Request?: Uint8Array;
                Response?: Uint8Array;
                Description?: string;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.BeaconID != null) {
                data.BeaconID = this.BeaconID;
            }
            if (this.CreatedAt != null) {
                data.CreatedAt = this.CreatedAt;
            }
            if (this.State != null) {
                data.State = this.State;
            }
            if (this.SentAt != null) {
                data.SentAt = this.SentAt;
            }
            if (this.CompletedAt != null) {
                data.CompletedAt = this.CompletedAt;
            }
            if (this.Request != null) {
                data.Request = this.Request;
            }
            if (this.Response != null) {
                data.Response = this.Response;
            }
            if (this.Description != null) {
                data.Description = this.Description;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ID === "string" && this.ID.length)
                writer.writeString(1, this.ID);
            if (typeof this.BeaconID === "string" && this.BeaconID.length)
                writer.writeString(2, this.BeaconID);
            if (this.CreatedAt !== undefined)
                writer.writeInt64(3, this.CreatedAt);
            if (typeof this.State === "string" && this.State.length)
                writer.writeString(4, this.State);
            if (this.SentAt !== undefined)
                writer.writeInt64(5, this.SentAt);
            if (this.CompletedAt !== undefined)
                writer.writeInt64(6, this.CompletedAt);
            if (this.Request !== undefined)
                writer.writeBytes(7, this.Request);
            if (this.Response !== undefined)
                writer.writeBytes(8, this.Response);
            if (typeof this.Description === "string" && this.Description.length)
                writer.writeString(9, this.Description);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BeaconTask {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BeaconTask();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readString();
                        break;
                    case 2:
                        message.BeaconID = reader.readString();
                        break;
                    case 3:
                        message.CreatedAt = reader.readInt64();
                        break;
                    case 4:
                        message.State = reader.readString();
                        break;
                    case 5:
                        message.SentAt = reader.readInt64();
                        break;
                    case 6:
                        message.CompletedAt = reader.readInt64();
                        break;
                    case 7:
                        message.Request = reader.readBytes();
                        break;
                    case 8:
                        message.Response = reader.readBytes();
                        break;
                    case 9:
                        message.Description = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BeaconTask {
            return BeaconTask.deserialize(bytes);
        }
    }
    export class BeaconTasks extends pb_1.Message {
        constructor(data?: any[] | {
            BeaconID?: string;
            Tasks?: BeaconTask[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("BeaconID" in data && data.BeaconID != undefined) {
                    this.BeaconID = data.BeaconID;
                }
                if ("Tasks" in data && data.Tasks != undefined) {
                    this.Tasks = data.Tasks;
                }
            }
        }
        get BeaconID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set BeaconID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Tasks() {
            return pb_1.Message.getRepeatedWrapperField(this, BeaconTask, 2) as BeaconTask[];
        }
        set Tasks(value: BeaconTask[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            BeaconID?: string;
            Tasks?: ReturnType<typeof BeaconTask.prototype.toObject>[];
        }) {
            const message = new BeaconTasks({});
            if (data.BeaconID != null) {
                message.BeaconID = data.BeaconID;
            }
            if (data.Tasks != null) {
                message.Tasks = data.Tasks.map(item => BeaconTask.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                BeaconID?: string;
                Tasks?: ReturnType<typeof BeaconTask.prototype.toObject>[];
            } = {};
            if (this.BeaconID != null) {
                data.BeaconID = this.BeaconID;
            }
            if (this.Tasks != null) {
                data.Tasks = this.Tasks.map((item: BeaconTask) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.BeaconID === "string" && this.BeaconID.length)
                writer.writeString(1, this.BeaconID);
            if (this.Tasks !== undefined)
                writer.writeRepeatedMessage(2, this.Tasks, (item: BeaconTask) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BeaconTasks {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BeaconTasks();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.BeaconID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Tasks, () => pb_1.Message.addToRepeatedWrapperField(message, 2, BeaconTask.deserialize(reader), BeaconTask));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BeaconTasks {
            return BeaconTasks.deserialize(bytes);
        }
    }
    export class ImplantC2 extends pb_1.Message {
        constructor(data?: any[] | {
            Priority?: number;
            URL?: string;
            Options?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Priority" in data && data.Priority != undefined) {
                    this.Priority = data.Priority;
                }
                if ("URL" in data && data.URL != undefined) {
                    this.URL = data.URL;
                }
                if ("Options" in data && data.Options != undefined) {
                    this.Options = data.Options;
                }
            }
        }
        get Priority() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set Priority(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get URL() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set URL(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Options() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Options(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Priority?: number;
            URL?: string;
            Options?: string;
        }) {
            const message = new ImplantC2({});
            if (data.Priority != null) {
                message.Priority = data.Priority;
            }
            if (data.URL != null) {
                message.URL = data.URL;
            }
            if (data.Options != null) {
                message.Options = data.Options;
            }
            return message;
        }
        toObject() {
            const data: {
                Priority?: number;
                URL?: string;
                Options?: string;
            } = {};
            if (this.Priority != null) {
                data.Priority = this.Priority;
            }
            if (this.URL != null) {
                data.URL = this.URL;
            }
            if (this.Options != null) {
                data.Options = this.Options;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Priority !== undefined)
                writer.writeUint32(1, this.Priority);
            if (typeof this.URL === "string" && this.URL.length)
                writer.writeString(2, this.URL);
            if (typeof this.Options === "string" && this.Options.length)
                writer.writeString(3, this.Options);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImplantC2 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImplantC2();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Priority = reader.readUint32();
                        break;
                    case 2:
                        message.URL = reader.readString();
                        break;
                    case 3:
                        message.Options = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImplantC2 {
            return ImplantC2.deserialize(bytes);
        }
    }
    export class ImplantConfig extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: string;
            IsBeacon?: boolean;
            BeaconInterval?: number;
            BeaconJitter?: number;
            GOOS?: string;
            GOARCH?: string;
            Name?: string;
            Debug?: boolean;
            Evasion?: boolean;
            ObfuscateSymbols?: boolean;
            MtlsCACert?: string;
            MtlsCert?: string;
            MtlsKey?: string;
            ECCPublicKey?: string;
            ECCPrivateKey?: string;
            ECCPublicKeySignature?: string;
            MinisignServerPublicKey?: string;
            WGImplantPrivKey?: string;
            WGServerPubKey?: string;
            WGPeerTunIP?: string;
            WGKeyExchangePort?: number;
            WGTcpCommsPort?: number;
            ReconnectInterval?: number;
            MaxConnectionErrors?: number;
            PollTimeout?: number;
            C2?: ImplantC2[];
            CanaryDomains?: string[];
            ConnectionStrategy?: string;
            LimitDomainJoined?: boolean;
            LimitDatetime?: string;
            LimitHostname?: string;
            LimitUsername?: string;
            LimitFileExists?: string;
            Format?: OutputFormat;
            IsSharedLib?: boolean;
            FileName?: string;
            IsService?: boolean;
            IsShellcode?: boolean;
            RunAtLoad?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [50, 51], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("IsBeacon" in data && data.IsBeacon != undefined) {
                    this.IsBeacon = data.IsBeacon;
                }
                if ("BeaconInterval" in data && data.BeaconInterval != undefined) {
                    this.BeaconInterval = data.BeaconInterval;
                }
                if ("BeaconJitter" in data && data.BeaconJitter != undefined) {
                    this.BeaconJitter = data.BeaconJitter;
                }
                if ("GOOS" in data && data.GOOS != undefined) {
                    this.GOOS = data.GOOS;
                }
                if ("GOARCH" in data && data.GOARCH != undefined) {
                    this.GOARCH = data.GOARCH;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Debug" in data && data.Debug != undefined) {
                    this.Debug = data.Debug;
                }
                if ("Evasion" in data && data.Evasion != undefined) {
                    this.Evasion = data.Evasion;
                }
                if ("ObfuscateSymbols" in data && data.ObfuscateSymbols != undefined) {
                    this.ObfuscateSymbols = data.ObfuscateSymbols;
                }
                if ("MtlsCACert" in data && data.MtlsCACert != undefined) {
                    this.MtlsCACert = data.MtlsCACert;
                }
                if ("MtlsCert" in data && data.MtlsCert != undefined) {
                    this.MtlsCert = data.MtlsCert;
                }
                if ("MtlsKey" in data && data.MtlsKey != undefined) {
                    this.MtlsKey = data.MtlsKey;
                }
                if ("ECCPublicKey" in data && data.ECCPublicKey != undefined) {
                    this.ECCPublicKey = data.ECCPublicKey;
                }
                if ("ECCPrivateKey" in data && data.ECCPrivateKey != undefined) {
                    this.ECCPrivateKey = data.ECCPrivateKey;
                }
                if ("ECCPublicKeySignature" in data && data.ECCPublicKeySignature != undefined) {
                    this.ECCPublicKeySignature = data.ECCPublicKeySignature;
                }
                if ("MinisignServerPublicKey" in data && data.MinisignServerPublicKey != undefined) {
                    this.MinisignServerPublicKey = data.MinisignServerPublicKey;
                }
                if ("WGImplantPrivKey" in data && data.WGImplantPrivKey != undefined) {
                    this.WGImplantPrivKey = data.WGImplantPrivKey;
                }
                if ("WGServerPubKey" in data && data.WGServerPubKey != undefined) {
                    this.WGServerPubKey = data.WGServerPubKey;
                }
                if ("WGPeerTunIP" in data && data.WGPeerTunIP != undefined) {
                    this.WGPeerTunIP = data.WGPeerTunIP;
                }
                if ("WGKeyExchangePort" in data && data.WGKeyExchangePort != undefined) {
                    this.WGKeyExchangePort = data.WGKeyExchangePort;
                }
                if ("WGTcpCommsPort" in data && data.WGTcpCommsPort != undefined) {
                    this.WGTcpCommsPort = data.WGTcpCommsPort;
                }
                if ("ReconnectInterval" in data && data.ReconnectInterval != undefined) {
                    this.ReconnectInterval = data.ReconnectInterval;
                }
                if ("MaxConnectionErrors" in data && data.MaxConnectionErrors != undefined) {
                    this.MaxConnectionErrors = data.MaxConnectionErrors;
                }
                if ("PollTimeout" in data && data.PollTimeout != undefined) {
                    this.PollTimeout = data.PollTimeout;
                }
                if ("C2" in data && data.C2 != undefined) {
                    this.C2 = data.C2;
                }
                if ("CanaryDomains" in data && data.CanaryDomains != undefined) {
                    this.CanaryDomains = data.CanaryDomains;
                }
                if ("ConnectionStrategy" in data && data.ConnectionStrategy != undefined) {
                    this.ConnectionStrategy = data.ConnectionStrategy;
                }
                if ("LimitDomainJoined" in data && data.LimitDomainJoined != undefined) {
                    this.LimitDomainJoined = data.LimitDomainJoined;
                }
                if ("LimitDatetime" in data && data.LimitDatetime != undefined) {
                    this.LimitDatetime = data.LimitDatetime;
                }
                if ("LimitHostname" in data && data.LimitHostname != undefined) {
                    this.LimitHostname = data.LimitHostname;
                }
                if ("LimitUsername" in data && data.LimitUsername != undefined) {
                    this.LimitUsername = data.LimitUsername;
                }
                if ("LimitFileExists" in data && data.LimitFileExists != undefined) {
                    this.LimitFileExists = data.LimitFileExists;
                }
                if ("Format" in data && data.Format != undefined) {
                    this.Format = data.Format;
                }
                if ("IsSharedLib" in data && data.IsSharedLib != undefined) {
                    this.IsSharedLib = data.IsSharedLib;
                }
                if ("FileName" in data && data.FileName != undefined) {
                    this.FileName = data.FileName;
                }
                if ("IsService" in data && data.IsService != undefined) {
                    this.IsService = data.IsService;
                }
                if ("IsShellcode" in data && data.IsShellcode != undefined) {
                    this.IsShellcode = data.IsShellcode;
                }
                if ("RunAtLoad" in data && data.RunAtLoad != undefined) {
                    this.RunAtLoad = data.RunAtLoad;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get IsBeacon() {
            return pb_1.Message.getField(this, 2) as boolean;
        }
        set IsBeacon(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get BeaconInterval() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set BeaconInterval(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get BeaconJitter() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set BeaconJitter(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get GOOS() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set GOOS(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get GOARCH() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set GOARCH(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get Debug() {
            return pb_1.Message.getField(this, 8) as boolean;
        }
        set Debug(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get Evasion() {
            return pb_1.Message.getField(this, 9) as boolean;
        }
        set Evasion(value: boolean) {
            pb_1.Message.setField(this, 9, value);
        }
        get ObfuscateSymbols() {
            return pb_1.Message.getField(this, 10) as boolean;
        }
        set ObfuscateSymbols(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get MtlsCACert() {
            return pb_1.Message.getField(this, 20) as string;
        }
        set MtlsCACert(value: string) {
            pb_1.Message.setField(this, 20, value);
        }
        get MtlsCert() {
            return pb_1.Message.getField(this, 21) as string;
        }
        set MtlsCert(value: string) {
            pb_1.Message.setField(this, 21, value);
        }
        get MtlsKey() {
            return pb_1.Message.getField(this, 22) as string;
        }
        set MtlsKey(value: string) {
            pb_1.Message.setField(this, 22, value);
        }
        get ECCPublicKey() {
            return pb_1.Message.getField(this, 23) as string;
        }
        set ECCPublicKey(value: string) {
            pb_1.Message.setField(this, 23, value);
        }
        get ECCPrivateKey() {
            return pb_1.Message.getField(this, 24) as string;
        }
        set ECCPrivateKey(value: string) {
            pb_1.Message.setField(this, 24, value);
        }
        get ECCPublicKeySignature() {
            return pb_1.Message.getField(this, 25) as string;
        }
        set ECCPublicKeySignature(value: string) {
            pb_1.Message.setField(this, 25, value);
        }
        get MinisignServerPublicKey() {
            return pb_1.Message.getField(this, 26) as string;
        }
        set MinisignServerPublicKey(value: string) {
            pb_1.Message.setField(this, 26, value);
        }
        get WGImplantPrivKey() {
            return pb_1.Message.getField(this, 30) as string;
        }
        set WGImplantPrivKey(value: string) {
            pb_1.Message.setField(this, 30, value);
        }
        get WGServerPubKey() {
            return pb_1.Message.getField(this, 31) as string;
        }
        set WGServerPubKey(value: string) {
            pb_1.Message.setField(this, 31, value);
        }
        get WGPeerTunIP() {
            return pb_1.Message.getField(this, 32) as string;
        }
        set WGPeerTunIP(value: string) {
            pb_1.Message.setField(this, 32, value);
        }
        get WGKeyExchangePort() {
            return pb_1.Message.getField(this, 33) as number;
        }
        set WGKeyExchangePort(value: number) {
            pb_1.Message.setField(this, 33, value);
        }
        get WGTcpCommsPort() {
            return pb_1.Message.getField(this, 34) as number;
        }
        set WGTcpCommsPort(value: number) {
            pb_1.Message.setField(this, 34, value);
        }
        get ReconnectInterval() {
            return pb_1.Message.getField(this, 40) as number;
        }
        set ReconnectInterval(value: number) {
            pb_1.Message.setField(this, 40, value);
        }
        get MaxConnectionErrors() {
            return pb_1.Message.getField(this, 41) as number;
        }
        set MaxConnectionErrors(value: number) {
            pb_1.Message.setField(this, 41, value);
        }
        get PollTimeout() {
            return pb_1.Message.getField(this, 42) as number;
        }
        set PollTimeout(value: number) {
            pb_1.Message.setField(this, 42, value);
        }
        get C2() {
            return pb_1.Message.getRepeatedWrapperField(this, ImplantC2, 50) as ImplantC2[];
        }
        set C2(value: ImplantC2[]) {
            pb_1.Message.setRepeatedWrapperField(this, 50, value);
        }
        get CanaryDomains() {
            return pb_1.Message.getField(this, 51) as string[];
        }
        set CanaryDomains(value: string[]) {
            pb_1.Message.setField(this, 51, value);
        }
        get ConnectionStrategy() {
            return pb_1.Message.getField(this, 52) as string;
        }
        set ConnectionStrategy(value: string) {
            pb_1.Message.setField(this, 52, value);
        }
        get LimitDomainJoined() {
            return pb_1.Message.getField(this, 60) as boolean;
        }
        set LimitDomainJoined(value: boolean) {
            pb_1.Message.setField(this, 60, value);
        }
        get LimitDatetime() {
            return pb_1.Message.getField(this, 61) as string;
        }
        set LimitDatetime(value: string) {
            pb_1.Message.setField(this, 61, value);
        }
        get LimitHostname() {
            return pb_1.Message.getField(this, 62) as string;
        }
        set LimitHostname(value: string) {
            pb_1.Message.setField(this, 62, value);
        }
        get LimitUsername() {
            return pb_1.Message.getField(this, 63) as string;
        }
        set LimitUsername(value: string) {
            pb_1.Message.setField(this, 63, value);
        }
        get LimitFileExists() {
            return pb_1.Message.getField(this, 64) as string;
        }
        set LimitFileExists(value: string) {
            pb_1.Message.setField(this, 64, value);
        }
        get Format() {
            return pb_1.Message.getField(this, 100) as OutputFormat;
        }
        set Format(value: OutputFormat) {
            pb_1.Message.setField(this, 100, value);
        }
        get IsSharedLib() {
            return pb_1.Message.getField(this, 101) as boolean;
        }
        set IsSharedLib(value: boolean) {
            pb_1.Message.setField(this, 101, value);
        }
        get FileName() {
            return pb_1.Message.getField(this, 102) as string;
        }
        set FileName(value: string) {
            pb_1.Message.setField(this, 102, value);
        }
        get IsService() {
            return pb_1.Message.getField(this, 103) as boolean;
        }
        set IsService(value: boolean) {
            pb_1.Message.setField(this, 103, value);
        }
        get IsShellcode() {
            return pb_1.Message.getField(this, 104) as boolean;
        }
        set IsShellcode(value: boolean) {
            pb_1.Message.setField(this, 104, value);
        }
        get RunAtLoad() {
            return pb_1.Message.getField(this, 105) as boolean;
        }
        set RunAtLoad(value: boolean) {
            pb_1.Message.setField(this, 105, value);
        }
        static fromObject(data: {
            ID?: string;
            IsBeacon?: boolean;
            BeaconInterval?: number;
            BeaconJitter?: number;
            GOOS?: string;
            GOARCH?: string;
            Name?: string;
            Debug?: boolean;
            Evasion?: boolean;
            ObfuscateSymbols?: boolean;
            MtlsCACert?: string;
            MtlsCert?: string;
            MtlsKey?: string;
            ECCPublicKey?: string;
            ECCPrivateKey?: string;
            ECCPublicKeySignature?: string;
            MinisignServerPublicKey?: string;
            WGImplantPrivKey?: string;
            WGServerPubKey?: string;
            WGPeerTunIP?: string;
            WGKeyExchangePort?: number;
            WGTcpCommsPort?: number;
            ReconnectInterval?: number;
            MaxConnectionErrors?: number;
            PollTimeout?: number;
            C2?: ReturnType<typeof ImplantC2.prototype.toObject>[];
            CanaryDomains?: string[];
            ConnectionStrategy?: string;
            LimitDomainJoined?: boolean;
            LimitDatetime?: string;
            LimitHostname?: string;
            LimitUsername?: string;
            LimitFileExists?: string;
            Format?: OutputFormat;
            IsSharedLib?: boolean;
            FileName?: string;
            IsService?: boolean;
            IsShellcode?: boolean;
            RunAtLoad?: boolean;
        }) {
            const message = new ImplantConfig({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.IsBeacon != null) {
                message.IsBeacon = data.IsBeacon;
            }
            if (data.BeaconInterval != null) {
                message.BeaconInterval = data.BeaconInterval;
            }
            if (data.BeaconJitter != null) {
                message.BeaconJitter = data.BeaconJitter;
            }
            if (data.GOOS != null) {
                message.GOOS = data.GOOS;
            }
            if (data.GOARCH != null) {
                message.GOARCH = data.GOARCH;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Debug != null) {
                message.Debug = data.Debug;
            }
            if (data.Evasion != null) {
                message.Evasion = data.Evasion;
            }
            if (data.ObfuscateSymbols != null) {
                message.ObfuscateSymbols = data.ObfuscateSymbols;
            }
            if (data.MtlsCACert != null) {
                message.MtlsCACert = data.MtlsCACert;
            }
            if (data.MtlsCert != null) {
                message.MtlsCert = data.MtlsCert;
            }
            if (data.MtlsKey != null) {
                message.MtlsKey = data.MtlsKey;
            }
            if (data.ECCPublicKey != null) {
                message.ECCPublicKey = data.ECCPublicKey;
            }
            if (data.ECCPrivateKey != null) {
                message.ECCPrivateKey = data.ECCPrivateKey;
            }
            if (data.ECCPublicKeySignature != null) {
                message.ECCPublicKeySignature = data.ECCPublicKeySignature;
            }
            if (data.MinisignServerPublicKey != null) {
                message.MinisignServerPublicKey = data.MinisignServerPublicKey;
            }
            if (data.WGImplantPrivKey != null) {
                message.WGImplantPrivKey = data.WGImplantPrivKey;
            }
            if (data.WGServerPubKey != null) {
                message.WGServerPubKey = data.WGServerPubKey;
            }
            if (data.WGPeerTunIP != null) {
                message.WGPeerTunIP = data.WGPeerTunIP;
            }
            if (data.WGKeyExchangePort != null) {
                message.WGKeyExchangePort = data.WGKeyExchangePort;
            }
            if (data.WGTcpCommsPort != null) {
                message.WGTcpCommsPort = data.WGTcpCommsPort;
            }
            if (data.ReconnectInterval != null) {
                message.ReconnectInterval = data.ReconnectInterval;
            }
            if (data.MaxConnectionErrors != null) {
                message.MaxConnectionErrors = data.MaxConnectionErrors;
            }
            if (data.PollTimeout != null) {
                message.PollTimeout = data.PollTimeout;
            }
            if (data.C2 != null) {
                message.C2 = data.C2.map(item => ImplantC2.fromObject(item));
            }
            if (data.CanaryDomains != null) {
                message.CanaryDomains = data.CanaryDomains;
            }
            if (data.ConnectionStrategy != null) {
                message.ConnectionStrategy = data.ConnectionStrategy;
            }
            if (data.LimitDomainJoined != null) {
                message.LimitDomainJoined = data.LimitDomainJoined;
            }
            if (data.LimitDatetime != null) {
                message.LimitDatetime = data.LimitDatetime;
            }
            if (data.LimitHostname != null) {
                message.LimitHostname = data.LimitHostname;
            }
            if (data.LimitUsername != null) {
                message.LimitUsername = data.LimitUsername;
            }
            if (data.LimitFileExists != null) {
                message.LimitFileExists = data.LimitFileExists;
            }
            if (data.Format != null) {
                message.Format = data.Format;
            }
            if (data.IsSharedLib != null) {
                message.IsSharedLib = data.IsSharedLib;
            }
            if (data.FileName != null) {
                message.FileName = data.FileName;
            }
            if (data.IsService != null) {
                message.IsService = data.IsService;
            }
            if (data.IsShellcode != null) {
                message.IsShellcode = data.IsShellcode;
            }
            if (data.RunAtLoad != null) {
                message.RunAtLoad = data.RunAtLoad;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: string;
                IsBeacon?: boolean;
                BeaconInterval?: number;
                BeaconJitter?: number;
                GOOS?: string;
                GOARCH?: string;
                Name?: string;
                Debug?: boolean;
                Evasion?: boolean;
                ObfuscateSymbols?: boolean;
                MtlsCACert?: string;
                MtlsCert?: string;
                MtlsKey?: string;
                ECCPublicKey?: string;
                ECCPrivateKey?: string;
                ECCPublicKeySignature?: string;
                MinisignServerPublicKey?: string;
                WGImplantPrivKey?: string;
                WGServerPubKey?: string;
                WGPeerTunIP?: string;
                WGKeyExchangePort?: number;
                WGTcpCommsPort?: number;
                ReconnectInterval?: number;
                MaxConnectionErrors?: number;
                PollTimeout?: number;
                C2?: ReturnType<typeof ImplantC2.prototype.toObject>[];
                CanaryDomains?: string[];
                ConnectionStrategy?: string;
                LimitDomainJoined?: boolean;
                LimitDatetime?: string;
                LimitHostname?: string;
                LimitUsername?: string;
                LimitFileExists?: string;
                Format?: OutputFormat;
                IsSharedLib?: boolean;
                FileName?: string;
                IsService?: boolean;
                IsShellcode?: boolean;
                RunAtLoad?: boolean;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.IsBeacon != null) {
                data.IsBeacon = this.IsBeacon;
            }
            if (this.BeaconInterval != null) {
                data.BeaconInterval = this.BeaconInterval;
            }
            if (this.BeaconJitter != null) {
                data.BeaconJitter = this.BeaconJitter;
            }
            if (this.GOOS != null) {
                data.GOOS = this.GOOS;
            }
            if (this.GOARCH != null) {
                data.GOARCH = this.GOARCH;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Debug != null) {
                data.Debug = this.Debug;
            }
            if (this.Evasion != null) {
                data.Evasion = this.Evasion;
            }
            if (this.ObfuscateSymbols != null) {
                data.ObfuscateSymbols = this.ObfuscateSymbols;
            }
            if (this.MtlsCACert != null) {
                data.MtlsCACert = this.MtlsCACert;
            }
            if (this.MtlsCert != null) {
                data.MtlsCert = this.MtlsCert;
            }
            if (this.MtlsKey != null) {
                data.MtlsKey = this.MtlsKey;
            }
            if (this.ECCPublicKey != null) {
                data.ECCPublicKey = this.ECCPublicKey;
            }
            if (this.ECCPrivateKey != null) {
                data.ECCPrivateKey = this.ECCPrivateKey;
            }
            if (this.ECCPublicKeySignature != null) {
                data.ECCPublicKeySignature = this.ECCPublicKeySignature;
            }
            if (this.MinisignServerPublicKey != null) {
                data.MinisignServerPublicKey = this.MinisignServerPublicKey;
            }
            if (this.WGImplantPrivKey != null) {
                data.WGImplantPrivKey = this.WGImplantPrivKey;
            }
            if (this.WGServerPubKey != null) {
                data.WGServerPubKey = this.WGServerPubKey;
            }
            if (this.WGPeerTunIP != null) {
                data.WGPeerTunIP = this.WGPeerTunIP;
            }
            if (this.WGKeyExchangePort != null) {
                data.WGKeyExchangePort = this.WGKeyExchangePort;
            }
            if (this.WGTcpCommsPort != null) {
                data.WGTcpCommsPort = this.WGTcpCommsPort;
            }
            if (this.ReconnectInterval != null) {
                data.ReconnectInterval = this.ReconnectInterval;
            }
            if (this.MaxConnectionErrors != null) {
                data.MaxConnectionErrors = this.MaxConnectionErrors;
            }
            if (this.PollTimeout != null) {
                data.PollTimeout = this.PollTimeout;
            }
            if (this.C2 != null) {
                data.C2 = this.C2.map((item: ImplantC2) => item.toObject());
            }
            if (this.CanaryDomains != null) {
                data.CanaryDomains = this.CanaryDomains;
            }
            if (this.ConnectionStrategy != null) {
                data.ConnectionStrategy = this.ConnectionStrategy;
            }
            if (this.LimitDomainJoined != null) {
                data.LimitDomainJoined = this.LimitDomainJoined;
            }
            if (this.LimitDatetime != null) {
                data.LimitDatetime = this.LimitDatetime;
            }
            if (this.LimitHostname != null) {
                data.LimitHostname = this.LimitHostname;
            }
            if (this.LimitUsername != null) {
                data.LimitUsername = this.LimitUsername;
            }
            if (this.LimitFileExists != null) {
                data.LimitFileExists = this.LimitFileExists;
            }
            if (this.Format != null) {
                data.Format = this.Format;
            }
            if (this.IsSharedLib != null) {
                data.IsSharedLib = this.IsSharedLib;
            }
            if (this.FileName != null) {
                data.FileName = this.FileName;
            }
            if (this.IsService != null) {
                data.IsService = this.IsService;
            }
            if (this.IsShellcode != null) {
                data.IsShellcode = this.IsShellcode;
            }
            if (this.RunAtLoad != null) {
                data.RunAtLoad = this.RunAtLoad;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ID === "string" && this.ID.length)
                writer.writeString(1, this.ID);
            if (this.IsBeacon !== undefined)
                writer.writeBool(2, this.IsBeacon);
            if (this.BeaconInterval !== undefined)
                writer.writeInt64(3, this.BeaconInterval);
            if (this.BeaconJitter !== undefined)
                writer.writeInt64(4, this.BeaconJitter);
            if (typeof this.GOOS === "string" && this.GOOS.length)
                writer.writeString(5, this.GOOS);
            if (typeof this.GOARCH === "string" && this.GOARCH.length)
                writer.writeString(6, this.GOARCH);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(7, this.Name);
            if (this.Debug !== undefined)
                writer.writeBool(8, this.Debug);
            if (this.Evasion !== undefined)
                writer.writeBool(9, this.Evasion);
            if (this.ObfuscateSymbols !== undefined)
                writer.writeBool(10, this.ObfuscateSymbols);
            if (typeof this.MtlsCACert === "string" && this.MtlsCACert.length)
                writer.writeString(20, this.MtlsCACert);
            if (typeof this.MtlsCert === "string" && this.MtlsCert.length)
                writer.writeString(21, this.MtlsCert);
            if (typeof this.MtlsKey === "string" && this.MtlsKey.length)
                writer.writeString(22, this.MtlsKey);
            if (typeof this.ECCPublicKey === "string" && this.ECCPublicKey.length)
                writer.writeString(23, this.ECCPublicKey);
            if (typeof this.ECCPrivateKey === "string" && this.ECCPrivateKey.length)
                writer.writeString(24, this.ECCPrivateKey);
            if (typeof this.ECCPublicKeySignature === "string" && this.ECCPublicKeySignature.length)
                writer.writeString(25, this.ECCPublicKeySignature);
            if (typeof this.MinisignServerPublicKey === "string" && this.MinisignServerPublicKey.length)
                writer.writeString(26, this.MinisignServerPublicKey);
            if (typeof this.WGImplantPrivKey === "string" && this.WGImplantPrivKey.length)
                writer.writeString(30, this.WGImplantPrivKey);
            if (typeof this.WGServerPubKey === "string" && this.WGServerPubKey.length)
                writer.writeString(31, this.WGServerPubKey);
            if (typeof this.WGPeerTunIP === "string" && this.WGPeerTunIP.length)
                writer.writeString(32, this.WGPeerTunIP);
            if (this.WGKeyExchangePort !== undefined)
                writer.writeUint32(33, this.WGKeyExchangePort);
            if (this.WGTcpCommsPort !== undefined)
                writer.writeUint32(34, this.WGTcpCommsPort);
            if (this.ReconnectInterval !== undefined)
                writer.writeInt64(40, this.ReconnectInterval);
            if (this.MaxConnectionErrors !== undefined)
                writer.writeUint32(41, this.MaxConnectionErrors);
            if (this.PollTimeout !== undefined)
                writer.writeInt64(42, this.PollTimeout);
            if (this.C2 !== undefined)
                writer.writeRepeatedMessage(50, this.C2, (item: ImplantC2) => item.serialize(writer));
            if (this.CanaryDomains !== undefined)
                writer.writeRepeatedString(51, this.CanaryDomains);
            if (typeof this.ConnectionStrategy === "string" && this.ConnectionStrategy.length)
                writer.writeString(52, this.ConnectionStrategy);
            if (this.LimitDomainJoined !== undefined)
                writer.writeBool(60, this.LimitDomainJoined);
            if (typeof this.LimitDatetime === "string" && this.LimitDatetime.length)
                writer.writeString(61, this.LimitDatetime);
            if (typeof this.LimitHostname === "string" && this.LimitHostname.length)
                writer.writeString(62, this.LimitHostname);
            if (typeof this.LimitUsername === "string" && this.LimitUsername.length)
                writer.writeString(63, this.LimitUsername);
            if (typeof this.LimitFileExists === "string" && this.LimitFileExists.length)
                writer.writeString(64, this.LimitFileExists);
            if (this.Format !== undefined)
                writer.writeEnum(100, this.Format);
            if (this.IsSharedLib !== undefined)
                writer.writeBool(101, this.IsSharedLib);
            if (typeof this.FileName === "string" && this.FileName.length)
                writer.writeString(102, this.FileName);
            if (this.IsService !== undefined)
                writer.writeBool(103, this.IsService);
            if (this.IsShellcode !== undefined)
                writer.writeBool(104, this.IsShellcode);
            if (this.RunAtLoad !== undefined)
                writer.writeBool(105, this.RunAtLoad);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImplantConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImplantConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readString();
                        break;
                    case 2:
                        message.IsBeacon = reader.readBool();
                        break;
                    case 3:
                        message.BeaconInterval = reader.readInt64();
                        break;
                    case 4:
                        message.BeaconJitter = reader.readInt64();
                        break;
                    case 5:
                        message.GOOS = reader.readString();
                        break;
                    case 6:
                        message.GOARCH = reader.readString();
                        break;
                    case 7:
                        message.Name = reader.readString();
                        break;
                    case 8:
                        message.Debug = reader.readBool();
                        break;
                    case 9:
                        message.Evasion = reader.readBool();
                        break;
                    case 10:
                        message.ObfuscateSymbols = reader.readBool();
                        break;
                    case 20:
                        message.MtlsCACert = reader.readString();
                        break;
                    case 21:
                        message.MtlsCert = reader.readString();
                        break;
                    case 22:
                        message.MtlsKey = reader.readString();
                        break;
                    case 23:
                        message.ECCPublicKey = reader.readString();
                        break;
                    case 24:
                        message.ECCPrivateKey = reader.readString();
                        break;
                    case 25:
                        message.ECCPublicKeySignature = reader.readString();
                        break;
                    case 26:
                        message.MinisignServerPublicKey = reader.readString();
                        break;
                    case 30:
                        message.WGImplantPrivKey = reader.readString();
                        break;
                    case 31:
                        message.WGServerPubKey = reader.readString();
                        break;
                    case 32:
                        message.WGPeerTunIP = reader.readString();
                        break;
                    case 33:
                        message.WGKeyExchangePort = reader.readUint32();
                        break;
                    case 34:
                        message.WGTcpCommsPort = reader.readUint32();
                        break;
                    case 40:
                        message.ReconnectInterval = reader.readInt64();
                        break;
                    case 41:
                        message.MaxConnectionErrors = reader.readUint32();
                        break;
                    case 42:
                        message.PollTimeout = reader.readInt64();
                        break;
                    case 50:
                        reader.readMessage(message.C2, () => pb_1.Message.addToRepeatedWrapperField(message, 50, ImplantC2.deserialize(reader), ImplantC2));
                        break;
                    case 51:
                        pb_1.Message.addToRepeatedField(message, 51, reader.readString());
                        break;
                    case 52:
                        message.ConnectionStrategy = reader.readString();
                        break;
                    case 60:
                        message.LimitDomainJoined = reader.readBool();
                        break;
                    case 61:
                        message.LimitDatetime = reader.readString();
                        break;
                    case 62:
                        message.LimitHostname = reader.readString();
                        break;
                    case 63:
                        message.LimitUsername = reader.readString();
                        break;
                    case 64:
                        message.LimitFileExists = reader.readString();
                        break;
                    case 100:
                        message.Format = reader.readEnum();
                        break;
                    case 101:
                        message.IsSharedLib = reader.readBool();
                        break;
                    case 102:
                        message.FileName = reader.readString();
                        break;
                    case 103:
                        message.IsService = reader.readBool();
                        break;
                    case 104:
                        message.IsShellcode = reader.readBool();
                        break;
                    case 105:
                        message.RunAtLoad = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImplantConfig {
            return ImplantConfig.deserialize(bytes);
        }
    }
    export class ImplantBuilds extends pb_1.Message {
        constructor(data?: any[] | {
            Configs?: Map<string, ImplantConfig>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Configs" in data && data.Configs != undefined) {
                    this.Configs = data.Configs;
                }
            }
            if (!this.Configs)
                this.Configs = new Map();
        }
        get Configs() {
            return pb_1.Message.getField(this, 1) as any as Map<string, ImplantConfig>;
        }
        set Configs(value: Map<string, ImplantConfig>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            Configs?: {
                [key: string]: ReturnType<typeof ImplantConfig.prototype.toObject>;
            };
        }) {
            const message = new ImplantBuilds({});
            if (typeof data.Configs == "object") {
                message.Configs = new Map(Object.entries(data.Configs).map(([key, value]) => [key, ImplantConfig.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Configs?: {
                    [key: string]: ReturnType<typeof ImplantConfig.prototype.toObject>;
                };
            } = {};
            if (this.Configs.size > 0) {
                data.Configs = Object.fromEntries(Array.from(this.Configs).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.Configs) {
                writer.writeMessage(1, this.Configs, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImplantBuilds {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImplantBuilds();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Configs as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = ImplantConfig.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImplantBuilds {
            return ImplantBuilds.deserialize(bytes);
        }
    }
    export class CompilerTarget extends pb_1.Message {
        constructor(data?: any[] | {
            GOOS?: string;
            GOARCH?: string;
            Format?: OutputFormat;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("GOOS" in data && data.GOOS != undefined) {
                    this.GOOS = data.GOOS;
                }
                if ("GOARCH" in data && data.GOARCH != undefined) {
                    this.GOARCH = data.GOARCH;
                }
                if ("Format" in data && data.Format != undefined) {
                    this.Format = data.Format;
                }
            }
        }
        get GOOS() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set GOOS(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get GOARCH() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set GOARCH(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Format() {
            return pb_1.Message.getField(this, 3) as OutputFormat;
        }
        set Format(value: OutputFormat) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            GOOS?: string;
            GOARCH?: string;
            Format?: OutputFormat;
        }) {
            const message = new CompilerTarget({});
            if (data.GOOS != null) {
                message.GOOS = data.GOOS;
            }
            if (data.GOARCH != null) {
                message.GOARCH = data.GOARCH;
            }
            if (data.Format != null) {
                message.Format = data.Format;
            }
            return message;
        }
        toObject() {
            const data: {
                GOOS?: string;
                GOARCH?: string;
                Format?: OutputFormat;
            } = {};
            if (this.GOOS != null) {
                data.GOOS = this.GOOS;
            }
            if (this.GOARCH != null) {
                data.GOARCH = this.GOARCH;
            }
            if (this.Format != null) {
                data.Format = this.Format;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.GOOS === "string" && this.GOOS.length)
                writer.writeString(1, this.GOOS);
            if (typeof this.GOARCH === "string" && this.GOARCH.length)
                writer.writeString(2, this.GOARCH);
            if (this.Format !== undefined)
                writer.writeEnum(3, this.Format);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompilerTarget {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompilerTarget();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.GOOS = reader.readString();
                        break;
                    case 2:
                        message.GOARCH = reader.readString();
                        break;
                    case 3:
                        message.Format = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompilerTarget {
            return CompilerTarget.deserialize(bytes);
        }
    }
    export class CrossCompiler extends pb_1.Message {
        constructor(data?: any[] | {
            TargetGOOS?: string;
            TargetGOARCH?: string;
            CCPath?: string;
            CXXPath?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("TargetGOOS" in data && data.TargetGOOS != undefined) {
                    this.TargetGOOS = data.TargetGOOS;
                }
                if ("TargetGOARCH" in data && data.TargetGOARCH != undefined) {
                    this.TargetGOARCH = data.TargetGOARCH;
                }
                if ("CCPath" in data && data.CCPath != undefined) {
                    this.CCPath = data.CCPath;
                }
                if ("CXXPath" in data && data.CXXPath != undefined) {
                    this.CXXPath = data.CXXPath;
                }
            }
        }
        get TargetGOOS() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set TargetGOOS(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get TargetGOARCH() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set TargetGOARCH(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get CCPath() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set CCPath(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get CXXPath() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set CXXPath(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            TargetGOOS?: string;
            TargetGOARCH?: string;
            CCPath?: string;
            CXXPath?: string;
        }) {
            const message = new CrossCompiler({});
            if (data.TargetGOOS != null) {
                message.TargetGOOS = data.TargetGOOS;
            }
            if (data.TargetGOARCH != null) {
                message.TargetGOARCH = data.TargetGOARCH;
            }
            if (data.CCPath != null) {
                message.CCPath = data.CCPath;
            }
            if (data.CXXPath != null) {
                message.CXXPath = data.CXXPath;
            }
            return message;
        }
        toObject() {
            const data: {
                TargetGOOS?: string;
                TargetGOARCH?: string;
                CCPath?: string;
                CXXPath?: string;
            } = {};
            if (this.TargetGOOS != null) {
                data.TargetGOOS = this.TargetGOOS;
            }
            if (this.TargetGOARCH != null) {
                data.TargetGOARCH = this.TargetGOARCH;
            }
            if (this.CCPath != null) {
                data.CCPath = this.CCPath;
            }
            if (this.CXXPath != null) {
                data.CXXPath = this.CXXPath;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.TargetGOOS === "string" && this.TargetGOOS.length)
                writer.writeString(1, this.TargetGOOS);
            if (typeof this.TargetGOARCH === "string" && this.TargetGOARCH.length)
                writer.writeString(2, this.TargetGOARCH);
            if (typeof this.CCPath === "string" && this.CCPath.length)
                writer.writeString(3, this.CCPath);
            if (typeof this.CXXPath === "string" && this.CXXPath.length)
                writer.writeString(4, this.CXXPath);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CrossCompiler {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CrossCompiler();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.TargetGOOS = reader.readString();
                        break;
                    case 2:
                        message.TargetGOARCH = reader.readString();
                        break;
                    case 3:
                        message.CCPath = reader.readString();
                        break;
                    case 4:
                        message.CXXPath = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CrossCompiler {
            return CrossCompiler.deserialize(bytes);
        }
    }
    export class Compiler extends pb_1.Message {
        constructor(data?: any[] | {
            GOOS?: string;
            GOARCH?: string;
            Targets?: CompilerTarget[];
            CrossCompilers?: CrossCompiler[];
            UnsupportedTargets?: CompilerTarget[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4, 5], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("GOOS" in data && data.GOOS != undefined) {
                    this.GOOS = data.GOOS;
                }
                if ("GOARCH" in data && data.GOARCH != undefined) {
                    this.GOARCH = data.GOARCH;
                }
                if ("Targets" in data && data.Targets != undefined) {
                    this.Targets = data.Targets;
                }
                if ("CrossCompilers" in data && data.CrossCompilers != undefined) {
                    this.CrossCompilers = data.CrossCompilers;
                }
                if ("UnsupportedTargets" in data && data.UnsupportedTargets != undefined) {
                    this.UnsupportedTargets = data.UnsupportedTargets;
                }
            }
        }
        get GOOS() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set GOOS(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get GOARCH() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set GOARCH(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Targets() {
            return pb_1.Message.getRepeatedWrapperField(this, CompilerTarget, 3) as CompilerTarget[];
        }
        set Targets(value: CompilerTarget[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get CrossCompilers() {
            return pb_1.Message.getRepeatedWrapperField(this, CrossCompiler, 4) as CrossCompiler[];
        }
        set CrossCompilers(value: CrossCompiler[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get UnsupportedTargets() {
            return pb_1.Message.getRepeatedWrapperField(this, CompilerTarget, 5) as CompilerTarget[];
        }
        set UnsupportedTargets(value: CompilerTarget[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        static fromObject(data: {
            GOOS?: string;
            GOARCH?: string;
            Targets?: ReturnType<typeof CompilerTarget.prototype.toObject>[];
            CrossCompilers?: ReturnType<typeof CrossCompiler.prototype.toObject>[];
            UnsupportedTargets?: ReturnType<typeof CompilerTarget.prototype.toObject>[];
        }) {
            const message = new Compiler({});
            if (data.GOOS != null) {
                message.GOOS = data.GOOS;
            }
            if (data.GOARCH != null) {
                message.GOARCH = data.GOARCH;
            }
            if (data.Targets != null) {
                message.Targets = data.Targets.map(item => CompilerTarget.fromObject(item));
            }
            if (data.CrossCompilers != null) {
                message.CrossCompilers = data.CrossCompilers.map(item => CrossCompiler.fromObject(item));
            }
            if (data.UnsupportedTargets != null) {
                message.UnsupportedTargets = data.UnsupportedTargets.map(item => CompilerTarget.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                GOOS?: string;
                GOARCH?: string;
                Targets?: ReturnType<typeof CompilerTarget.prototype.toObject>[];
                CrossCompilers?: ReturnType<typeof CrossCompiler.prototype.toObject>[];
                UnsupportedTargets?: ReturnType<typeof CompilerTarget.prototype.toObject>[];
            } = {};
            if (this.GOOS != null) {
                data.GOOS = this.GOOS;
            }
            if (this.GOARCH != null) {
                data.GOARCH = this.GOARCH;
            }
            if (this.Targets != null) {
                data.Targets = this.Targets.map((item: CompilerTarget) => item.toObject());
            }
            if (this.CrossCompilers != null) {
                data.CrossCompilers = this.CrossCompilers.map((item: CrossCompiler) => item.toObject());
            }
            if (this.UnsupportedTargets != null) {
                data.UnsupportedTargets = this.UnsupportedTargets.map((item: CompilerTarget) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.GOOS === "string" && this.GOOS.length)
                writer.writeString(1, this.GOOS);
            if (typeof this.GOARCH === "string" && this.GOARCH.length)
                writer.writeString(2, this.GOARCH);
            if (this.Targets !== undefined)
                writer.writeRepeatedMessage(3, this.Targets, (item: CompilerTarget) => item.serialize(writer));
            if (this.CrossCompilers !== undefined)
                writer.writeRepeatedMessage(4, this.CrossCompilers, (item: CrossCompiler) => item.serialize(writer));
            if (this.UnsupportedTargets !== undefined)
                writer.writeRepeatedMessage(5, this.UnsupportedTargets, (item: CompilerTarget) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Compiler {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Compiler();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.GOOS = reader.readString();
                        break;
                    case 2:
                        message.GOARCH = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.Targets, () => pb_1.Message.addToRepeatedWrapperField(message, 3, CompilerTarget.deserialize(reader), CompilerTarget));
                        break;
                    case 4:
                        reader.readMessage(message.CrossCompilers, () => pb_1.Message.addToRepeatedWrapperField(message, 4, CrossCompiler.deserialize(reader), CrossCompiler));
                        break;
                    case 5:
                        reader.readMessage(message.UnsupportedTargets, () => pb_1.Message.addToRepeatedWrapperField(message, 5, CompilerTarget.deserialize(reader), CompilerTarget));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Compiler {
            return Compiler.deserialize(bytes);
        }
    }
    export class DeleteReq extends pb_1.Message {
        constructor(data?: any[] | {
            Name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
            }
        }
        get Name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            Name?: string;
        }) {
            const message = new DeleteReq({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(1, this.Name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteReq {
            return DeleteReq.deserialize(bytes);
        }
    }
    export class DNSCanary extends pb_1.Message {
        constructor(data?: any[] | {
            ImplantName?: string;
            Domain?: string;
            Triggered?: boolean;
            FirstTriggered?: string;
            LatestTrigger?: string;
            Count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ImplantName" in data && data.ImplantName != undefined) {
                    this.ImplantName = data.ImplantName;
                }
                if ("Domain" in data && data.Domain != undefined) {
                    this.Domain = data.Domain;
                }
                if ("Triggered" in data && data.Triggered != undefined) {
                    this.Triggered = data.Triggered;
                }
                if ("FirstTriggered" in data && data.FirstTriggered != undefined) {
                    this.FirstTriggered = data.FirstTriggered;
                }
                if ("LatestTrigger" in data && data.LatestTrigger != undefined) {
                    this.LatestTrigger = data.LatestTrigger;
                }
                if ("Count" in data && data.Count != undefined) {
                    this.Count = data.Count;
                }
            }
        }
        get ImplantName() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ImplantName(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Domain() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Domain(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Triggered() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set Triggered(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get FirstTriggered() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set FirstTriggered(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get LatestTrigger() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set LatestTrigger(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get Count() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set Count(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            ImplantName?: string;
            Domain?: string;
            Triggered?: boolean;
            FirstTriggered?: string;
            LatestTrigger?: string;
            Count?: number;
        }) {
            const message = new DNSCanary({});
            if (data.ImplantName != null) {
                message.ImplantName = data.ImplantName;
            }
            if (data.Domain != null) {
                message.Domain = data.Domain;
            }
            if (data.Triggered != null) {
                message.Triggered = data.Triggered;
            }
            if (data.FirstTriggered != null) {
                message.FirstTriggered = data.FirstTriggered;
            }
            if (data.LatestTrigger != null) {
                message.LatestTrigger = data.LatestTrigger;
            }
            if (data.Count != null) {
                message.Count = data.Count;
            }
            return message;
        }
        toObject() {
            const data: {
                ImplantName?: string;
                Domain?: string;
                Triggered?: boolean;
                FirstTriggered?: string;
                LatestTrigger?: string;
                Count?: number;
            } = {};
            if (this.ImplantName != null) {
                data.ImplantName = this.ImplantName;
            }
            if (this.Domain != null) {
                data.Domain = this.Domain;
            }
            if (this.Triggered != null) {
                data.Triggered = this.Triggered;
            }
            if (this.FirstTriggered != null) {
                data.FirstTriggered = this.FirstTriggered;
            }
            if (this.LatestTrigger != null) {
                data.LatestTrigger = this.LatestTrigger;
            }
            if (this.Count != null) {
                data.Count = this.Count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ImplantName === "string" && this.ImplantName.length)
                writer.writeString(1, this.ImplantName);
            if (typeof this.Domain === "string" && this.Domain.length)
                writer.writeString(2, this.Domain);
            if (this.Triggered !== undefined)
                writer.writeBool(3, this.Triggered);
            if (typeof this.FirstTriggered === "string" && this.FirstTriggered.length)
                writer.writeString(4, this.FirstTriggered);
            if (typeof this.LatestTrigger === "string" && this.LatestTrigger.length)
                writer.writeString(5, this.LatestTrigger);
            if (this.Count !== undefined)
                writer.writeUint32(6, this.Count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DNSCanary {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DNSCanary();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ImplantName = reader.readString();
                        break;
                    case 2:
                        message.Domain = reader.readString();
                        break;
                    case 3:
                        message.Triggered = reader.readBool();
                        break;
                    case 4:
                        message.FirstTriggered = reader.readString();
                        break;
                    case 5:
                        message.LatestTrigger = reader.readString();
                        break;
                    case 6:
                        message.Count = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DNSCanary {
            return DNSCanary.deserialize(bytes);
        }
    }
    export class Canaries extends pb_1.Message {
        constructor(data?: any[] | {
            Canaries?: DNSCanary[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Canaries" in data && data.Canaries != undefined) {
                    this.Canaries = data.Canaries;
                }
            }
        }
        get Canaries() {
            return pb_1.Message.getRepeatedWrapperField(this, DNSCanary, 1) as DNSCanary[];
        }
        set Canaries(value: DNSCanary[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Canaries?: ReturnType<typeof DNSCanary.prototype.toObject>[];
        }) {
            const message = new Canaries({});
            if (data.Canaries != null) {
                message.Canaries = data.Canaries.map(item => DNSCanary.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Canaries?: ReturnType<typeof DNSCanary.prototype.toObject>[];
            } = {};
            if (this.Canaries != null) {
                data.Canaries = this.Canaries.map((item: DNSCanary) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Canaries !== undefined)
                writer.writeRepeatedMessage(1, this.Canaries, (item: DNSCanary) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Canaries {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Canaries();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Canaries, () => pb_1.Message.addToRepeatedWrapperField(message, 1, DNSCanary.deserialize(reader), DNSCanary));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Canaries {
            return Canaries.deserialize(bytes);
        }
    }
    export class UniqueWGIP extends pb_1.Message {
        constructor(data?: any[] | {
            IP?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("IP" in data && data.IP != undefined) {
                    this.IP = data.IP;
                }
            }
        }
        get IP() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set IP(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            IP?: string;
        }) {
            const message = new UniqueWGIP({});
            if (data.IP != null) {
                message.IP = data.IP;
            }
            return message;
        }
        toObject() {
            const data: {
                IP?: string;
            } = {};
            if (this.IP != null) {
                data.IP = this.IP;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.IP === "string" && this.IP.length)
                writer.writeString(1, this.IP);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UniqueWGIP {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UniqueWGIP();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.IP = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UniqueWGIP {
            return UniqueWGIP.deserialize(bytes);
        }
    }
    export class ImplantProfile extends pb_1.Message {
        constructor(data?: any[] | {
            Name?: string;
            Config?: ImplantConfig;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Config" in data && data.Config != undefined) {
                    this.Config = data.Config;
                }
            }
        }
        get Name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Config() {
            return pb_1.Message.getWrapperField(this, ImplantConfig, 2) as ImplantConfig;
        }
        set Config(value: ImplantConfig) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            Name?: string;
            Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
        }) {
            const message = new ImplantProfile({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Config != null) {
                message.Config = ImplantConfig.fromObject(data.Config);
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
                Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Config != null) {
                data.Config = this.Config.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(1, this.Name);
            if (this.Config !== undefined)
                writer.writeMessage(2, this.Config, () => this.Config.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImplantProfile {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImplantProfile();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Config, () => message.Config = ImplantConfig.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImplantProfile {
            return ImplantProfile.deserialize(bytes);
        }
    }
    export class ImplantProfiles extends pb_1.Message {
        constructor(data?: any[] | {
            Profiles?: ImplantProfile[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Profiles" in data && data.Profiles != undefined) {
                    this.Profiles = data.Profiles;
                }
            }
        }
        get Profiles() {
            return pb_1.Message.getRepeatedWrapperField(this, ImplantProfile, 1) as ImplantProfile[];
        }
        set Profiles(value: ImplantProfile[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Profiles?: ReturnType<typeof ImplantProfile.prototype.toObject>[];
        }) {
            const message = new ImplantProfiles({});
            if (data.Profiles != null) {
                message.Profiles = data.Profiles.map(item => ImplantProfile.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Profiles?: ReturnType<typeof ImplantProfile.prototype.toObject>[];
            } = {};
            if (this.Profiles != null) {
                data.Profiles = this.Profiles.map((item: ImplantProfile) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Profiles !== undefined)
                writer.writeRepeatedMessage(1, this.Profiles, (item: ImplantProfile) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImplantProfiles {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImplantProfiles();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Profiles, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ImplantProfile.deserialize(reader), ImplantProfile));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImplantProfiles {
            return ImplantProfiles.deserialize(bytes);
        }
    }
    export class RegenerateReq extends pb_1.Message {
        constructor(data?: any[] | {
            ImplantName?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ImplantName" in data && data.ImplantName != undefined) {
                    this.ImplantName = data.ImplantName;
                }
            }
        }
        get ImplantName() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ImplantName(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ImplantName?: string;
        }) {
            const message = new RegenerateReq({});
            if (data.ImplantName != null) {
                message.ImplantName = data.ImplantName;
            }
            return message;
        }
        toObject() {
            const data: {
                ImplantName?: string;
            } = {};
            if (this.ImplantName != null) {
                data.ImplantName = this.ImplantName;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ImplantName === "string" && this.ImplantName.length)
                writer.writeString(1, this.ImplantName);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RegenerateReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RegenerateReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ImplantName = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RegenerateReq {
            return RegenerateReq.deserialize(bytes);
        }
    }
    export class Job extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: number;
            Name?: string;
            Description?: string;
            Protocol?: string;
            Port?: number;
            Domains?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Description" in data && data.Description != undefined) {
                    this.Description = data.Description;
                }
                if ("Protocol" in data && data.Protocol != undefined) {
                    this.Protocol = data.Protocol;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Domains" in data && data.Domains != undefined) {
                    this.Domains = data.Domains;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set ID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Description() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Description(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Protocol() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set Protocol(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Domains() {
            return pb_1.Message.getField(this, 6) as string[];
        }
        set Domains(value: string[]) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            ID?: number;
            Name?: string;
            Description?: string;
            Protocol?: string;
            Port?: number;
            Domains?: string[];
        }) {
            const message = new Job({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Description != null) {
                message.Description = data.Description;
            }
            if (data.Protocol != null) {
                message.Protocol = data.Protocol;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Domains != null) {
                message.Domains = data.Domains;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: number;
                Name?: string;
                Description?: string;
                Protocol?: string;
                Port?: number;
                Domains?: string[];
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Description != null) {
                data.Description = this.Description;
            }
            if (this.Protocol != null) {
                data.Protocol = this.Protocol;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Domains != null) {
                data.Domains = this.Domains;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID !== undefined)
                writer.writeUint32(1, this.ID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(2, this.Name);
            if (typeof this.Description === "string" && this.Description.length)
                writer.writeString(3, this.Description);
            if (typeof this.Protocol === "string" && this.Protocol.length)
                writer.writeString(4, this.Protocol);
            if (this.Port !== undefined)
                writer.writeUint32(5, this.Port);
            if (this.Domains !== undefined)
                writer.writeRepeatedString(6, this.Domains);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Job {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Job();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readUint32();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    case 3:
                        message.Description = reader.readString();
                        break;
                    case 4:
                        message.Protocol = reader.readString();
                        break;
                    case 5:
                        message.Port = reader.readUint32();
                        break;
                    case 6:
                        pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Job {
            return Job.deserialize(bytes);
        }
    }
    export class Jobs extends pb_1.Message {
        constructor(data?: any[] | {
            Active?: Job[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Active" in data && data.Active != undefined) {
                    this.Active = data.Active;
                }
            }
        }
        get Active() {
            return pb_1.Message.getRepeatedWrapperField(this, Job, 1) as Job[];
        }
        set Active(value: Job[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Active?: ReturnType<typeof Job.prototype.toObject>[];
        }) {
            const message = new Jobs({});
            if (data.Active != null) {
                message.Active = data.Active.map(item => Job.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Active?: ReturnType<typeof Job.prototype.toObject>[];
            } = {};
            if (this.Active != null) {
                data.Active = this.Active.map((item: Job) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Active !== undefined)
                writer.writeRepeatedMessage(1, this.Active, (item: Job) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Jobs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Jobs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Active, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Job.deserialize(reader), Job));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Jobs {
            return Jobs.deserialize(bytes);
        }
    }
    export class KillJobReq extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set ID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ID?: number;
        }) {
            const message = new KillJobReq({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: number;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID !== undefined)
                writer.writeUint32(1, this.ID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KillJobReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KillJobReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KillJobReq {
            return KillJobReq.deserialize(bytes);
        }
    }
    export class KillJob extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: number;
            Success?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Success" in data && data.Success != undefined) {
                    this.Success = data.Success;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set ID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Success() {
            return pb_1.Message.getField(this, 2) as boolean;
        }
        set Success(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            ID?: number;
            Success?: boolean;
        }) {
            const message = new KillJob({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Success != null) {
                message.Success = data.Success;
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: number;
                Success?: boolean;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Success != null) {
                data.Success = this.Success;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID !== undefined)
                writer.writeUint32(1, this.ID);
            if (this.Success !== undefined)
                writer.writeBool(2, this.Success);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KillJob {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KillJob();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readUint32();
                        break;
                    case 2:
                        message.Success = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KillJob {
            return KillJob.deserialize(bytes);
        }
    }
    export class MTLSListenerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Host?: string;
            Port?: number;
            Persistent?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Persistent" in data && data.Persistent != undefined) {
                    this.Persistent = data.Persistent;
                }
            }
        }
        get Host() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get Persistent() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set Persistent(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Host?: string;
            Port?: number;
            Persistent?: boolean;
        }) {
            const message = new MTLSListenerReq({});
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Persistent != null) {
                message.Persistent = data.Persistent;
            }
            return message;
        }
        toObject() {
            const data: {
                Host?: string;
                Port?: number;
                Persistent?: boolean;
            } = {};
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Persistent != null) {
                data.Persistent = this.Persistent;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(1, this.Host);
            if (this.Port !== undefined)
                writer.writeUint32(2, this.Port);
            if (this.Persistent !== undefined)
                writer.writeBool(3, this.Persistent);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MTLSListenerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MTLSListenerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Host = reader.readString();
                        break;
                    case 2:
                        message.Port = reader.readUint32();
                        break;
                    case 3:
                        message.Persistent = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MTLSListenerReq {
            return MTLSListenerReq.deserialize(bytes);
        }
    }
    export class MTLSListener extends pb_1.Message {
        constructor(data?: any[] | {
            JobID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("JobID" in data && data.JobID != undefined) {
                    this.JobID = data.JobID;
                }
            }
        }
        get JobID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set JobID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            JobID?: number;
        }) {
            const message = new MTLSListener({});
            if (data.JobID != null) {
                message.JobID = data.JobID;
            }
            return message;
        }
        toObject() {
            const data: {
                JobID?: number;
            } = {};
            if (this.JobID != null) {
                data.JobID = this.JobID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.JobID !== undefined)
                writer.writeUint32(1, this.JobID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MTLSListener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MTLSListener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.JobID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MTLSListener {
            return MTLSListener.deserialize(bytes);
        }
    }
    export class WGListenerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Host?: string;
            Port?: number;
            TunIP?: string;
            NPort?: number;
            KeyPort?: number;
            Persistent?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("TunIP" in data && data.TunIP != undefined) {
                    this.TunIP = data.TunIP;
                }
                if ("NPort" in data && data.NPort != undefined) {
                    this.NPort = data.NPort;
                }
                if ("KeyPort" in data && data.KeyPort != undefined) {
                    this.KeyPort = data.KeyPort;
                }
                if ("Persistent" in data && data.Persistent != undefined) {
                    this.Persistent = data.Persistent;
                }
            }
        }
        get Host() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get TunIP() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set TunIP(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get NPort() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set NPort(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get KeyPort() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set KeyPort(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get Persistent() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set Persistent(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            Host?: string;
            Port?: number;
            TunIP?: string;
            NPort?: number;
            KeyPort?: number;
            Persistent?: boolean;
        }) {
            const message = new WGListenerReq({});
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.TunIP != null) {
                message.TunIP = data.TunIP;
            }
            if (data.NPort != null) {
                message.NPort = data.NPort;
            }
            if (data.KeyPort != null) {
                message.KeyPort = data.KeyPort;
            }
            if (data.Persistent != null) {
                message.Persistent = data.Persistent;
            }
            return message;
        }
        toObject() {
            const data: {
                Host?: string;
                Port?: number;
                TunIP?: string;
                NPort?: number;
                KeyPort?: number;
                Persistent?: boolean;
            } = {};
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.TunIP != null) {
                data.TunIP = this.TunIP;
            }
            if (this.NPort != null) {
                data.NPort = this.NPort;
            }
            if (this.KeyPort != null) {
                data.KeyPort = this.KeyPort;
            }
            if (this.Persistent != null) {
                data.Persistent = this.Persistent;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(6, this.Host);
            if (this.Port !== undefined)
                writer.writeUint32(1, this.Port);
            if (typeof this.TunIP === "string" && this.TunIP.length)
                writer.writeString(2, this.TunIP);
            if (this.NPort !== undefined)
                writer.writeUint32(3, this.NPort);
            if (this.KeyPort !== undefined)
                writer.writeUint32(4, this.KeyPort);
            if (this.Persistent !== undefined)
                writer.writeBool(5, this.Persistent);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WGListenerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WGListenerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 6:
                        message.Host = reader.readString();
                        break;
                    case 1:
                        message.Port = reader.readUint32();
                        break;
                    case 2:
                        message.TunIP = reader.readString();
                        break;
                    case 3:
                        message.NPort = reader.readUint32();
                        break;
                    case 4:
                        message.KeyPort = reader.readUint32();
                        break;
                    case 5:
                        message.Persistent = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WGListenerReq {
            return WGListenerReq.deserialize(bytes);
        }
    }
    export class WGListener extends pb_1.Message {
        constructor(data?: any[] | {
            JobID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("JobID" in data && data.JobID != undefined) {
                    this.JobID = data.JobID;
                }
            }
        }
        get JobID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set JobID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            JobID?: number;
        }) {
            const message = new WGListener({});
            if (data.JobID != null) {
                message.JobID = data.JobID;
            }
            return message;
        }
        toObject() {
            const data: {
                JobID?: number;
            } = {};
            if (this.JobID != null) {
                data.JobID = this.JobID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.JobID !== undefined)
                writer.writeUint32(1, this.JobID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WGListener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WGListener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.JobID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WGListener {
            return WGListener.deserialize(bytes);
        }
    }
    export class DNSListenerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Domains?: string[];
            Canaries?: boolean;
            Host?: string;
            Port?: number;
            Persistent?: boolean;
            EnforceOTP?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Domains" in data && data.Domains != undefined) {
                    this.Domains = data.Domains;
                }
                if ("Canaries" in data && data.Canaries != undefined) {
                    this.Canaries = data.Canaries;
                }
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Persistent" in data && data.Persistent != undefined) {
                    this.Persistent = data.Persistent;
                }
                if ("EnforceOTP" in data && data.EnforceOTP != undefined) {
                    this.EnforceOTP = data.EnforceOTP;
                }
            }
        }
        get Domains() {
            return pb_1.Message.getField(this, 1) as string[];
        }
        set Domains(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get Canaries() {
            return pb_1.Message.getField(this, 2) as boolean;
        }
        set Canaries(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get Host() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get Persistent() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set Persistent(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get EnforceOTP() {
            return pb_1.Message.getField(this, 6) as boolean;
        }
        set EnforceOTP(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            Domains?: string[];
            Canaries?: boolean;
            Host?: string;
            Port?: number;
            Persistent?: boolean;
            EnforceOTP?: boolean;
        }) {
            const message = new DNSListenerReq({});
            if (data.Domains != null) {
                message.Domains = data.Domains;
            }
            if (data.Canaries != null) {
                message.Canaries = data.Canaries;
            }
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Persistent != null) {
                message.Persistent = data.Persistent;
            }
            if (data.EnforceOTP != null) {
                message.EnforceOTP = data.EnforceOTP;
            }
            return message;
        }
        toObject() {
            const data: {
                Domains?: string[];
                Canaries?: boolean;
                Host?: string;
                Port?: number;
                Persistent?: boolean;
                EnforceOTP?: boolean;
            } = {};
            if (this.Domains != null) {
                data.Domains = this.Domains;
            }
            if (this.Canaries != null) {
                data.Canaries = this.Canaries;
            }
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Persistent != null) {
                data.Persistent = this.Persistent;
            }
            if (this.EnforceOTP != null) {
                data.EnforceOTP = this.EnforceOTP;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Domains !== undefined)
                writer.writeRepeatedString(1, this.Domains);
            if (this.Canaries !== undefined)
                writer.writeBool(2, this.Canaries);
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(3, this.Host);
            if (this.Port !== undefined)
                writer.writeUint32(4, this.Port);
            if (this.Persistent !== undefined)
                writer.writeBool(5, this.Persistent);
            if (this.EnforceOTP !== undefined)
                writer.writeBool(6, this.EnforceOTP);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DNSListenerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DNSListenerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        message.Canaries = reader.readBool();
                        break;
                    case 3:
                        message.Host = reader.readString();
                        break;
                    case 4:
                        message.Port = reader.readUint32();
                        break;
                    case 5:
                        message.Persistent = reader.readBool();
                        break;
                    case 6:
                        message.EnforceOTP = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DNSListenerReq {
            return DNSListenerReq.deserialize(bytes);
        }
    }
    export class DNSListener extends pb_1.Message {
        constructor(data?: any[] | {
            JobID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("JobID" in data && data.JobID != undefined) {
                    this.JobID = data.JobID;
                }
            }
        }
        get JobID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set JobID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            JobID?: number;
        }) {
            const message = new DNSListener({});
            if (data.JobID != null) {
                message.JobID = data.JobID;
            }
            return message;
        }
        toObject() {
            const data: {
                JobID?: number;
            } = {};
            if (this.JobID != null) {
                data.JobID = this.JobID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.JobID !== undefined)
                writer.writeUint32(1, this.JobID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DNSListener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DNSListener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.JobID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DNSListener {
            return DNSListener.deserialize(bytes);
        }
    }
    export class HTTPListenerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Domain?: string;
            Host?: string;
            Port?: number;
            Secure?: boolean;
            Website?: string;
            Cert?: Uint8Array;
            Key?: Uint8Array;
            ACME?: boolean;
            Persistent?: boolean;
            EnforceOTP?: boolean;
            LongPollTimeout?: number;
            LongPollJitter?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Domain" in data && data.Domain != undefined) {
                    this.Domain = data.Domain;
                }
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Secure" in data && data.Secure != undefined) {
                    this.Secure = data.Secure;
                }
                if ("Website" in data && data.Website != undefined) {
                    this.Website = data.Website;
                }
                if ("Cert" in data && data.Cert != undefined) {
                    this.Cert = data.Cert;
                }
                if ("Key" in data && data.Key != undefined) {
                    this.Key = data.Key;
                }
                if ("ACME" in data && data.ACME != undefined) {
                    this.ACME = data.ACME;
                }
                if ("Persistent" in data && data.Persistent != undefined) {
                    this.Persistent = data.Persistent;
                }
                if ("EnforceOTP" in data && data.EnforceOTP != undefined) {
                    this.EnforceOTP = data.EnforceOTP;
                }
                if ("LongPollTimeout" in data && data.LongPollTimeout != undefined) {
                    this.LongPollTimeout = data.LongPollTimeout;
                }
                if ("LongPollJitter" in data && data.LongPollJitter != undefined) {
                    this.LongPollJitter = data.LongPollJitter;
                }
            }
        }
        get Domain() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Domain(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Host() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Secure() {
            return pb_1.Message.getField(this, 4) as boolean;
        }
        set Secure(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get Website() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set Website(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get Cert() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set Cert(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get Key() {
            return pb_1.Message.getField(this, 7) as Uint8Array;
        }
        set Key(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get ACME() {
            return pb_1.Message.getField(this, 8) as boolean;
        }
        set ACME(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get Persistent() {
            return pb_1.Message.getField(this, 9) as boolean;
        }
        set Persistent(value: boolean) {
            pb_1.Message.setField(this, 9, value);
        }
        get EnforceOTP() {
            return pb_1.Message.getField(this, 10) as boolean;
        }
        set EnforceOTP(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get LongPollTimeout() {
            return pb_1.Message.getField(this, 11) as number;
        }
        set LongPollTimeout(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get LongPollJitter() {
            return pb_1.Message.getField(this, 12) as number;
        }
        set LongPollJitter(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        static fromObject(data: {
            Domain?: string;
            Host?: string;
            Port?: number;
            Secure?: boolean;
            Website?: string;
            Cert?: Uint8Array;
            Key?: Uint8Array;
            ACME?: boolean;
            Persistent?: boolean;
            EnforceOTP?: boolean;
            LongPollTimeout?: number;
            LongPollJitter?: number;
        }) {
            const message = new HTTPListenerReq({});
            if (data.Domain != null) {
                message.Domain = data.Domain;
            }
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Secure != null) {
                message.Secure = data.Secure;
            }
            if (data.Website != null) {
                message.Website = data.Website;
            }
            if (data.Cert != null) {
                message.Cert = data.Cert;
            }
            if (data.Key != null) {
                message.Key = data.Key;
            }
            if (data.ACME != null) {
                message.ACME = data.ACME;
            }
            if (data.Persistent != null) {
                message.Persistent = data.Persistent;
            }
            if (data.EnforceOTP != null) {
                message.EnforceOTP = data.EnforceOTP;
            }
            if (data.LongPollTimeout != null) {
                message.LongPollTimeout = data.LongPollTimeout;
            }
            if (data.LongPollJitter != null) {
                message.LongPollJitter = data.LongPollJitter;
            }
            return message;
        }
        toObject() {
            const data: {
                Domain?: string;
                Host?: string;
                Port?: number;
                Secure?: boolean;
                Website?: string;
                Cert?: Uint8Array;
                Key?: Uint8Array;
                ACME?: boolean;
                Persistent?: boolean;
                EnforceOTP?: boolean;
                LongPollTimeout?: number;
                LongPollJitter?: number;
            } = {};
            if (this.Domain != null) {
                data.Domain = this.Domain;
            }
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Secure != null) {
                data.Secure = this.Secure;
            }
            if (this.Website != null) {
                data.Website = this.Website;
            }
            if (this.Cert != null) {
                data.Cert = this.Cert;
            }
            if (this.Key != null) {
                data.Key = this.Key;
            }
            if (this.ACME != null) {
                data.ACME = this.ACME;
            }
            if (this.Persistent != null) {
                data.Persistent = this.Persistent;
            }
            if (this.EnforceOTP != null) {
                data.EnforceOTP = this.EnforceOTP;
            }
            if (this.LongPollTimeout != null) {
                data.LongPollTimeout = this.LongPollTimeout;
            }
            if (this.LongPollJitter != null) {
                data.LongPollJitter = this.LongPollJitter;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Domain === "string" && this.Domain.length)
                writer.writeString(1, this.Domain);
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(2, this.Host);
            if (this.Port !== undefined)
                writer.writeUint32(3, this.Port);
            if (this.Secure !== undefined)
                writer.writeBool(4, this.Secure);
            if (typeof this.Website === "string" && this.Website.length)
                writer.writeString(5, this.Website);
            if (this.Cert !== undefined)
                writer.writeBytes(6, this.Cert);
            if (this.Key !== undefined)
                writer.writeBytes(7, this.Key);
            if (this.ACME !== undefined)
                writer.writeBool(8, this.ACME);
            if (this.Persistent !== undefined)
                writer.writeBool(9, this.Persistent);
            if (this.EnforceOTP !== undefined)
                writer.writeBool(10, this.EnforceOTP);
            if (this.LongPollTimeout !== undefined)
                writer.writeInt64(11, this.LongPollTimeout);
            if (this.LongPollJitter !== undefined)
                writer.writeInt64(12, this.LongPollJitter);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HTTPListenerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HTTPListenerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Domain = reader.readString();
                        break;
                    case 2:
                        message.Host = reader.readString();
                        break;
                    case 3:
                        message.Port = reader.readUint32();
                        break;
                    case 4:
                        message.Secure = reader.readBool();
                        break;
                    case 5:
                        message.Website = reader.readString();
                        break;
                    case 6:
                        message.Cert = reader.readBytes();
                        break;
                    case 7:
                        message.Key = reader.readBytes();
                        break;
                    case 8:
                        message.ACME = reader.readBool();
                        break;
                    case 9:
                        message.Persistent = reader.readBool();
                        break;
                    case 10:
                        message.EnforceOTP = reader.readBool();
                        break;
                    case 11:
                        message.LongPollTimeout = reader.readInt64();
                        break;
                    case 12:
                        message.LongPollJitter = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HTTPListenerReq {
            return HTTPListenerReq.deserialize(bytes);
        }
    }
    export class NamedPipesReq extends pb_1.Message {
        constructor(data?: any[] | {
            PipeName?: string;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("PipeName" in data && data.PipeName != undefined) {
                    this.PipeName = data.PipeName;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get PipeName() {
            return pb_1.Message.getField(this, 16) as string;
        }
        set PipeName(value: string) {
            pb_1.Message.setField(this, 16, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            PipeName?: string;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new NamedPipesReq({});
            if (data.PipeName != null) {
                message.PipeName = data.PipeName;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                PipeName?: string;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.PipeName != null) {
                data.PipeName = this.PipeName;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.PipeName === "string" && this.PipeName.length)
                writer.writeString(16, this.PipeName);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NamedPipesReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NamedPipesReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 16:
                        message.PipeName = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NamedPipesReq {
            return NamedPipesReq.deserialize(bytes);
        }
    }
    export class NamedPipes extends pb_1.Message {
        constructor(data?: any[] | {
            Success?: boolean;
            Err?: string;
            Response?: dependency_1.commonpb.Response;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Success" in data && data.Success != undefined) {
                    this.Success = data.Success;
                }
                if ("Err" in data && data.Err != undefined) {
                    this.Err = data.Err;
                }
                if ("Response" in data && data.Response != undefined) {
                    this.Response = data.Response;
                }
            }
        }
        get Success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set Success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get Err() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Err(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Response() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Response, 9) as dependency_1.commonpb.Response;
        }
        set Response(value: dependency_1.commonpb.Response) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Success?: boolean;
            Err?: string;
            Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
        }) {
            const message = new NamedPipes({});
            if (data.Success != null) {
                message.Success = data.Success;
            }
            if (data.Err != null) {
                message.Err = data.Err;
            }
            if (data.Response != null) {
                message.Response = dependency_1.commonpb.Response.fromObject(data.Response);
            }
            return message;
        }
        toObject() {
            const data: {
                Success?: boolean;
                Err?: string;
                Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
            } = {};
            if (this.Success != null) {
                data.Success = this.Success;
            }
            if (this.Err != null) {
                data.Err = this.Err;
            }
            if (this.Response != null) {
                data.Response = this.Response.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Success !== undefined)
                writer.writeBool(1, this.Success);
            if (typeof this.Err === "string" && this.Err.length)
                writer.writeString(2, this.Err);
            if (this.Response !== undefined)
                writer.writeMessage(9, this.Response, () => this.Response.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NamedPipes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NamedPipes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Success = reader.readBool();
                        break;
                    case 2:
                        message.Err = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.Response, () => message.Response = dependency_1.commonpb.Response.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NamedPipes {
            return NamedPipes.deserialize(bytes);
        }
    }
    export class TCPPivotReq extends pb_1.Message {
        constructor(data?: any[] | {
            Address?: string;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Address" in data && data.Address != undefined) {
                    this.Address = data.Address;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Address() {
            return pb_1.Message.getField(this, 16) as string;
        }
        set Address(value: string) {
            pb_1.Message.setField(this, 16, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Address?: string;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new TCPPivotReq({});
            if (data.Address != null) {
                message.Address = data.Address;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Address?: string;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Address != null) {
                data.Address = this.Address;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Address === "string" && this.Address.length)
                writer.writeString(16, this.Address);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TCPPivotReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TCPPivotReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 16:
                        message.Address = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TCPPivotReq {
            return TCPPivotReq.deserialize(bytes);
        }
    }
    export class TCPPivot extends pb_1.Message {
        constructor(data?: any[] | {
            Success?: boolean;
            Err?: string;
            Response?: dependency_1.commonpb.Response;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Success" in data && data.Success != undefined) {
                    this.Success = data.Success;
                }
                if ("Err" in data && data.Err != undefined) {
                    this.Err = data.Err;
                }
                if ("Response" in data && data.Response != undefined) {
                    this.Response = data.Response;
                }
            }
        }
        get Success() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set Success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get Err() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Err(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Response() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Response, 9) as dependency_1.commonpb.Response;
        }
        set Response(value: dependency_1.commonpb.Response) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Success?: boolean;
            Err?: string;
            Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
        }) {
            const message = new TCPPivot({});
            if (data.Success != null) {
                message.Success = data.Success;
            }
            if (data.Err != null) {
                message.Err = data.Err;
            }
            if (data.Response != null) {
                message.Response = dependency_1.commonpb.Response.fromObject(data.Response);
            }
            return message;
        }
        toObject() {
            const data: {
                Success?: boolean;
                Err?: string;
                Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
            } = {};
            if (this.Success != null) {
                data.Success = this.Success;
            }
            if (this.Err != null) {
                data.Err = this.Err;
            }
            if (this.Response != null) {
                data.Response = this.Response.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Success !== undefined)
                writer.writeBool(1, this.Success);
            if (typeof this.Err === "string" && this.Err.length)
                writer.writeString(2, this.Err);
            if (this.Response !== undefined)
                writer.writeMessage(9, this.Response, () => this.Response.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TCPPivot {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TCPPivot();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Success = reader.readBool();
                        break;
                    case 2:
                        message.Err = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.Response, () => message.Response = dependency_1.commonpb.Response.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TCPPivot {
            return TCPPivot.deserialize(bytes);
        }
    }
    export class HTTPListener extends pb_1.Message {
        constructor(data?: any[] | {
            JobID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("JobID" in data && data.JobID != undefined) {
                    this.JobID = data.JobID;
                }
            }
        }
        get JobID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set JobID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            JobID?: number;
        }) {
            const message = new HTTPListener({});
            if (data.JobID != null) {
                message.JobID = data.JobID;
            }
            return message;
        }
        toObject() {
            const data: {
                JobID?: number;
            } = {};
            if (this.JobID != null) {
                data.JobID = this.JobID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.JobID !== undefined)
                writer.writeUint32(1, this.JobID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HTTPListener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HTTPListener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.JobID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HTTPListener {
            return HTTPListener.deserialize(bytes);
        }
    }
    export class Sessions extends pb_1.Message {
        constructor(data?: any[] | {
            Sessions?: Session[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Sessions" in data && data.Sessions != undefined) {
                    this.Sessions = data.Sessions;
                }
            }
        }
        get Sessions() {
            return pb_1.Message.getRepeatedWrapperField(this, Session, 1) as Session[];
        }
        set Sessions(value: Session[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Sessions?: ReturnType<typeof Session.prototype.toObject>[];
        }) {
            const message = new Sessions({});
            if (data.Sessions != null) {
                message.Sessions = data.Sessions.map(item => Session.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Sessions?: ReturnType<typeof Session.prototype.toObject>[];
            } = {};
            if (this.Sessions != null) {
                data.Sessions = this.Sessions.map((item: Session) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Sessions !== undefined)
                writer.writeRepeatedMessage(1, this.Sessions, (item: Session) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Sessions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Sessions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Sessions, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Session.deserialize(reader), Session));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Sessions {
            return Sessions.deserialize(bytes);
        }
    }
    export class RenameReq extends pb_1.Message {
        constructor(data?: any[] | {
            SessionID?: string;
            BeaconID?: string;
            Name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("SessionID" in data && data.SessionID != undefined) {
                    this.SessionID = data.SessionID;
                }
                if ("BeaconID" in data && data.BeaconID != undefined) {
                    this.BeaconID = data.BeaconID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
            }
        }
        get SessionID() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set SessionID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get BeaconID() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set BeaconID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            SessionID?: string;
            BeaconID?: string;
            Name?: string;
        }) {
            const message = new RenameReq({});
            if (data.SessionID != null) {
                message.SessionID = data.SessionID;
            }
            if (data.BeaconID != null) {
                message.BeaconID = data.BeaconID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            return message;
        }
        toObject() {
            const data: {
                SessionID?: string;
                BeaconID?: string;
                Name?: string;
            } = {};
            if (this.SessionID != null) {
                data.SessionID = this.SessionID;
            }
            if (this.BeaconID != null) {
                data.BeaconID = this.BeaconID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.SessionID === "string" && this.SessionID.length)
                writer.writeString(1, this.SessionID);
            if (typeof this.BeaconID === "string" && this.BeaconID.length)
                writer.writeString(2, this.BeaconID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(3, this.Name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RenameReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RenameReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.SessionID = reader.readString();
                        break;
                    case 2:
                        message.BeaconID = reader.readString();
                        break;
                    case 3:
                        message.Name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RenameReq {
            return RenameReq.deserialize(bytes);
        }
    }
    export class GenerateReq extends pb_1.Message {
        constructor(data?: any[] | {
            Config?: ImplantConfig;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Config" in data && data.Config != undefined) {
                    this.Config = data.Config;
                }
            }
        }
        get Config() {
            return pb_1.Message.getWrapperField(this, ImplantConfig, 1) as ImplantConfig;
        }
        set Config(value: ImplantConfig) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
        }) {
            const message = new GenerateReq({});
            if (data.Config != null) {
                message.Config = ImplantConfig.fromObject(data.Config);
            }
            return message;
        }
        toObject() {
            const data: {
                Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
            } = {};
            if (this.Config != null) {
                data.Config = this.Config.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Config !== undefined)
                writer.writeMessage(1, this.Config, () => this.Config.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GenerateReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GenerateReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Config, () => message.Config = ImplantConfig.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GenerateReq {
            return GenerateReq.deserialize(bytes);
        }
    }
    export class Generate extends pb_1.Message {
        constructor(data?: any[] | {
            File?: dependency_1.commonpb.File;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("File" in data && data.File != undefined) {
                    this.File = data.File;
                }
            }
        }
        get File() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.File, 1) as dependency_1.commonpb.File;
        }
        set File(value: dependency_1.commonpb.File) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        static fromObject(data: {
            File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
        }) {
            const message = new Generate({});
            if (data.File != null) {
                message.File = dependency_1.commonpb.File.fromObject(data.File);
            }
            return message;
        }
        toObject() {
            const data: {
                File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
            } = {};
            if (this.File != null) {
                data.File = this.File.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.File !== undefined)
                writer.writeMessage(1, this.File, () => this.File.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Generate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Generate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.File, () => message.File = dependency_1.commonpb.File.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Generate {
            return Generate.deserialize(bytes);
        }
    }
    export class MSFReq extends pb_1.Message {
        constructor(data?: any[] | {
            Payload?: string;
            LHost?: string;
            LPort?: number;
            Encoder?: string;
            Iterations?: number;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Payload" in data && data.Payload != undefined) {
                    this.Payload = data.Payload;
                }
                if ("LHost" in data && data.LHost != undefined) {
                    this.LHost = data.LHost;
                }
                if ("LPort" in data && data.LPort != undefined) {
                    this.LPort = data.LPort;
                }
                if ("Encoder" in data && data.Encoder != undefined) {
                    this.Encoder = data.Encoder;
                }
                if ("Iterations" in data && data.Iterations != undefined) {
                    this.Iterations = data.Iterations;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Payload() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Payload(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get LHost() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set LHost(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get LPort() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set LPort(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Encoder() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set Encoder(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Iterations() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set Iterations(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Payload?: string;
            LHost?: string;
            LPort?: number;
            Encoder?: string;
            Iterations?: number;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new MSFReq({});
            if (data.Payload != null) {
                message.Payload = data.Payload;
            }
            if (data.LHost != null) {
                message.LHost = data.LHost;
            }
            if (data.LPort != null) {
                message.LPort = data.LPort;
            }
            if (data.Encoder != null) {
                message.Encoder = data.Encoder;
            }
            if (data.Iterations != null) {
                message.Iterations = data.Iterations;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Payload?: string;
                LHost?: string;
                LPort?: number;
                Encoder?: string;
                Iterations?: number;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Payload != null) {
                data.Payload = this.Payload;
            }
            if (this.LHost != null) {
                data.LHost = this.LHost;
            }
            if (this.LPort != null) {
                data.LPort = this.LPort;
            }
            if (this.Encoder != null) {
                data.Encoder = this.Encoder;
            }
            if (this.Iterations != null) {
                data.Iterations = this.Iterations;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Payload === "string" && this.Payload.length)
                writer.writeString(1, this.Payload);
            if (typeof this.LHost === "string" && this.LHost.length)
                writer.writeString(2, this.LHost);
            if (this.LPort !== undefined)
                writer.writeUint32(3, this.LPort);
            if (typeof this.Encoder === "string" && this.Encoder.length)
                writer.writeString(4, this.Encoder);
            if (this.Iterations !== undefined)
                writer.writeInt32(5, this.Iterations);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MSFReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MSFReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Payload = reader.readString();
                        break;
                    case 2:
                        message.LHost = reader.readString();
                        break;
                    case 3:
                        message.LPort = reader.readUint32();
                        break;
                    case 4:
                        message.Encoder = reader.readString();
                        break;
                    case 5:
                        message.Iterations = reader.readInt32();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MSFReq {
            return MSFReq.deserialize(bytes);
        }
    }
    export class MSFRemoteReq extends pb_1.Message {
        constructor(data?: any[] | {
            Payload?: string;
            LHost?: string;
            LPort?: number;
            Encoder?: string;
            Iterations?: number;
            PID?: number;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Payload" in data && data.Payload != undefined) {
                    this.Payload = data.Payload;
                }
                if ("LHost" in data && data.LHost != undefined) {
                    this.LHost = data.LHost;
                }
                if ("LPort" in data && data.LPort != undefined) {
                    this.LPort = data.LPort;
                }
                if ("Encoder" in data && data.Encoder != undefined) {
                    this.Encoder = data.Encoder;
                }
                if ("Iterations" in data && data.Iterations != undefined) {
                    this.Iterations = data.Iterations;
                }
                if ("PID" in data && data.PID != undefined) {
                    this.PID = data.PID;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Payload() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Payload(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get LHost() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set LHost(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get LPort() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set LPort(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Encoder() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set Encoder(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Iterations() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set Iterations(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get PID() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set PID(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Payload?: string;
            LHost?: string;
            LPort?: number;
            Encoder?: string;
            Iterations?: number;
            PID?: number;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new MSFRemoteReq({});
            if (data.Payload != null) {
                message.Payload = data.Payload;
            }
            if (data.LHost != null) {
                message.LHost = data.LHost;
            }
            if (data.LPort != null) {
                message.LPort = data.LPort;
            }
            if (data.Encoder != null) {
                message.Encoder = data.Encoder;
            }
            if (data.Iterations != null) {
                message.Iterations = data.Iterations;
            }
            if (data.PID != null) {
                message.PID = data.PID;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Payload?: string;
                LHost?: string;
                LPort?: number;
                Encoder?: string;
                Iterations?: number;
                PID?: number;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Payload != null) {
                data.Payload = this.Payload;
            }
            if (this.LHost != null) {
                data.LHost = this.LHost;
            }
            if (this.LPort != null) {
                data.LPort = this.LPort;
            }
            if (this.Encoder != null) {
                data.Encoder = this.Encoder;
            }
            if (this.Iterations != null) {
                data.Iterations = this.Iterations;
            }
            if (this.PID != null) {
                data.PID = this.PID;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Payload === "string" && this.Payload.length)
                writer.writeString(1, this.Payload);
            if (typeof this.LHost === "string" && this.LHost.length)
                writer.writeString(2, this.LHost);
            if (this.LPort !== undefined)
                writer.writeUint32(3, this.LPort);
            if (typeof this.Encoder === "string" && this.Encoder.length)
                writer.writeString(4, this.Encoder);
            if (this.Iterations !== undefined)
                writer.writeInt32(5, this.Iterations);
            if (this.PID !== undefined)
                writer.writeUint32(8, this.PID);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MSFRemoteReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MSFRemoteReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Payload = reader.readString();
                        break;
                    case 2:
                        message.LHost = reader.readString();
                        break;
                    case 3:
                        message.LPort = reader.readUint32();
                        break;
                    case 4:
                        message.Encoder = reader.readString();
                        break;
                    case 5:
                        message.Iterations = reader.readInt32();
                        break;
                    case 8:
                        message.PID = reader.readUint32();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MSFRemoteReq {
            return MSFRemoteReq.deserialize(bytes);
        }
    }
    export class StagerListenerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Protocol?: StageProtocol;
            Host?: string;
            Port?: number;
            Data?: Uint8Array;
            Cert?: Uint8Array;
            Key?: Uint8Array;
            ACME?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Protocol" in data && data.Protocol != undefined) {
                    this.Protocol = data.Protocol;
                }
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
                if ("Cert" in data && data.Cert != undefined) {
                    this.Cert = data.Cert;
                }
                if ("Key" in data && data.Key != undefined) {
                    this.Key = data.Key;
                }
                if ("ACME" in data && data.ACME != undefined) {
                    this.ACME = data.ACME;
                }
            }
        }
        get Protocol() {
            return pb_1.Message.getField(this, 1) as StageProtocol;
        }
        set Protocol(value: StageProtocol) {
            pb_1.Message.setField(this, 1, value);
        }
        get Host() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Data() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get Cert() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set Cert(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get Key() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set Key(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get ACME() {
            return pb_1.Message.getField(this, 7) as boolean;
        }
        set ACME(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            Protocol?: StageProtocol;
            Host?: string;
            Port?: number;
            Data?: Uint8Array;
            Cert?: Uint8Array;
            Key?: Uint8Array;
            ACME?: boolean;
        }) {
            const message = new StagerListenerReq({});
            if (data.Protocol != null) {
                message.Protocol = data.Protocol;
            }
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Data != null) {
                message.Data = data.Data;
            }
            if (data.Cert != null) {
                message.Cert = data.Cert;
            }
            if (data.Key != null) {
                message.Key = data.Key;
            }
            if (data.ACME != null) {
                message.ACME = data.ACME;
            }
            return message;
        }
        toObject() {
            const data: {
                Protocol?: StageProtocol;
                Host?: string;
                Port?: number;
                Data?: Uint8Array;
                Cert?: Uint8Array;
                Key?: Uint8Array;
                ACME?: boolean;
            } = {};
            if (this.Protocol != null) {
                data.Protocol = this.Protocol;
            }
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Data != null) {
                data.Data = this.Data;
            }
            if (this.Cert != null) {
                data.Cert = this.Cert;
            }
            if (this.Key != null) {
                data.Key = this.Key;
            }
            if (this.ACME != null) {
                data.ACME = this.ACME;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Protocol !== undefined)
                writer.writeEnum(1, this.Protocol);
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(2, this.Host);
            if (this.Port !== undefined)
                writer.writeUint32(3, this.Port);
            if (this.Data !== undefined)
                writer.writeBytes(4, this.Data);
            if (this.Cert !== undefined)
                writer.writeBytes(5, this.Cert);
            if (this.Key !== undefined)
                writer.writeBytes(6, this.Key);
            if (this.ACME !== undefined)
                writer.writeBool(7, this.ACME);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StagerListenerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StagerListenerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Protocol = reader.readEnum();
                        break;
                    case 2:
                        message.Host = reader.readString();
                        break;
                    case 3:
                        message.Port = reader.readUint32();
                        break;
                    case 4:
                        message.Data = reader.readBytes();
                        break;
                    case 5:
                        message.Cert = reader.readBytes();
                        break;
                    case 6:
                        message.Key = reader.readBytes();
                        break;
                    case 7:
                        message.ACME = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StagerListenerReq {
            return StagerListenerReq.deserialize(bytes);
        }
    }
    export class StagerListener extends pb_1.Message {
        constructor(data?: any[] | {
            JobID?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("JobID" in data && data.JobID != undefined) {
                    this.JobID = data.JobID;
                }
            }
        }
        get JobID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set JobID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            JobID?: number;
        }) {
            const message = new StagerListener({});
            if (data.JobID != null) {
                message.JobID = data.JobID;
            }
            return message;
        }
        toObject() {
            const data: {
                JobID?: number;
            } = {};
            if (this.JobID != null) {
                data.JobID = this.JobID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.JobID !== undefined)
                writer.writeUint32(1, this.JobID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StagerListener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StagerListener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.JobID = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StagerListener {
            return StagerListener.deserialize(bytes);
        }
    }
    export class ShellcodeRDIReq extends pb_1.Message {
        constructor(data?: any[] | {
            Data?: Uint8Array;
            FunctionName?: string;
            Arguments?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
                if ("FunctionName" in data && data.FunctionName != undefined) {
                    this.FunctionName = data.FunctionName;
                }
                if ("Arguments" in data && data.Arguments != undefined) {
                    this.Arguments = data.Arguments;
                }
            }
        }
        get Data() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get FunctionName() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set FunctionName(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Arguments() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Arguments(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Data?: Uint8Array;
            FunctionName?: string;
            Arguments?: string;
        }) {
            const message = new ShellcodeRDIReq({});
            if (data.Data != null) {
                message.Data = data.Data;
            }
            if (data.FunctionName != null) {
                message.FunctionName = data.FunctionName;
            }
            if (data.Arguments != null) {
                message.Arguments = data.Arguments;
            }
            return message;
        }
        toObject() {
            const data: {
                Data?: Uint8Array;
                FunctionName?: string;
                Arguments?: string;
            } = {};
            if (this.Data != null) {
                data.Data = this.Data;
            }
            if (this.FunctionName != null) {
                data.FunctionName = this.FunctionName;
            }
            if (this.Arguments != null) {
                data.Arguments = this.Arguments;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Data !== undefined)
                writer.writeBytes(1, this.Data);
            if (typeof this.FunctionName === "string" && this.FunctionName.length)
                writer.writeString(2, this.FunctionName);
            if (typeof this.Arguments === "string" && this.Arguments.length)
                writer.writeString(3, this.Arguments);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShellcodeRDIReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShellcodeRDIReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Data = reader.readBytes();
                        break;
                    case 2:
                        message.FunctionName = reader.readString();
                        break;
                    case 3:
                        message.Arguments = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShellcodeRDIReq {
            return ShellcodeRDIReq.deserialize(bytes);
        }
    }
    export class ShellcodeRDI extends pb_1.Message {
        constructor(data?: any[] | {
            Data?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
            }
        }
        get Data() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            Data?: Uint8Array;
        }) {
            const message = new ShellcodeRDI({});
            if (data.Data != null) {
                message.Data = data.Data;
            }
            return message;
        }
        toObject() {
            const data: {
                Data?: Uint8Array;
            } = {};
            if (this.Data != null) {
                data.Data = this.Data;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Data !== undefined)
                writer.writeBytes(1, this.Data);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShellcodeRDI {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShellcodeRDI();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Data = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShellcodeRDI {
            return ShellcodeRDI.deserialize(bytes);
        }
    }
    export class MsfStagerReq extends pb_1.Message {
        constructor(data?: any[] | {
            Arch?: string;
            Format?: string;
            Port?: number;
            Host?: string;
            OS?: string;
            Protocol?: StageProtocol;
            BadChars?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Arch" in data && data.Arch != undefined) {
                    this.Arch = data.Arch;
                }
                if ("Format" in data && data.Format != undefined) {
                    this.Format = data.Format;
                }
                if ("Port" in data && data.Port != undefined) {
                    this.Port = data.Port;
                }
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("OS" in data && data.OS != undefined) {
                    this.OS = data.OS;
                }
                if ("Protocol" in data && data.Protocol != undefined) {
                    this.Protocol = data.Protocol;
                }
                if ("BadChars" in data && data.BadChars != undefined) {
                    this.BadChars = data.BadChars;
                }
            }
        }
        get Arch() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Arch(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Format() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Format(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Port() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set Port(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Host() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get OS() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set OS(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get Protocol() {
            return pb_1.Message.getField(this, 6) as StageProtocol;
        }
        set Protocol(value: StageProtocol) {
            pb_1.Message.setField(this, 6, value);
        }
        get BadChars() {
            return pb_1.Message.getField(this, 7) as string[];
        }
        set BadChars(value: string[]) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            Arch?: string;
            Format?: string;
            Port?: number;
            Host?: string;
            OS?: string;
            Protocol?: StageProtocol;
            BadChars?: string[];
        }) {
            const message = new MsfStagerReq({});
            if (data.Arch != null) {
                message.Arch = data.Arch;
            }
            if (data.Format != null) {
                message.Format = data.Format;
            }
            if (data.Port != null) {
                message.Port = data.Port;
            }
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.OS != null) {
                message.OS = data.OS;
            }
            if (data.Protocol != null) {
                message.Protocol = data.Protocol;
            }
            if (data.BadChars != null) {
                message.BadChars = data.BadChars;
            }
            return message;
        }
        toObject() {
            const data: {
                Arch?: string;
                Format?: string;
                Port?: number;
                Host?: string;
                OS?: string;
                Protocol?: StageProtocol;
                BadChars?: string[];
            } = {};
            if (this.Arch != null) {
                data.Arch = this.Arch;
            }
            if (this.Format != null) {
                data.Format = this.Format;
            }
            if (this.Port != null) {
                data.Port = this.Port;
            }
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.OS != null) {
                data.OS = this.OS;
            }
            if (this.Protocol != null) {
                data.Protocol = this.Protocol;
            }
            if (this.BadChars != null) {
                data.BadChars = this.BadChars;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Arch === "string" && this.Arch.length)
                writer.writeString(1, this.Arch);
            if (typeof this.Format === "string" && this.Format.length)
                writer.writeString(2, this.Format);
            if (this.Port !== undefined)
                writer.writeUint32(3, this.Port);
            if (typeof this.Host === "string" && this.Host.length)
                writer.writeString(4, this.Host);
            if (typeof this.OS === "string" && this.OS.length)
                writer.writeString(5, this.OS);
            if (this.Protocol !== undefined)
                writer.writeEnum(6, this.Protocol);
            if (this.BadChars !== undefined)
                writer.writeRepeatedString(7, this.BadChars);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsfStagerReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsfStagerReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Arch = reader.readString();
                        break;
                    case 2:
                        message.Format = reader.readString();
                        break;
                    case 3:
                        message.Port = reader.readUint32();
                        break;
                    case 4:
                        message.Host = reader.readString();
                        break;
                    case 5:
                        message.OS = reader.readString();
                        break;
                    case 6:
                        message.Protocol = reader.readEnum();
                        break;
                    case 7:
                        pb_1.Message.addToRepeatedField(message, 7, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsfStagerReq {
            return MsfStagerReq.deserialize(bytes);
        }
    }
    export class MsfStager extends pb_1.Message {
        constructor(data?: any[] | {
            File?: dependency_1.commonpb.File;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("File" in data && data.File != undefined) {
                    this.File = data.File;
                }
            }
        }
        get File() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.File, 1) as dependency_1.commonpb.File;
        }
        set File(value: dependency_1.commonpb.File) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        static fromObject(data: {
            File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
        }) {
            const message = new MsfStager({});
            if (data.File != null) {
                message.File = dependency_1.commonpb.File.fromObject(data.File);
            }
            return message;
        }
        toObject() {
            const data: {
                File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
            } = {};
            if (this.File != null) {
                data.File = this.File.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.File !== undefined)
                writer.writeMessage(1, this.File, () => this.File.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsfStager {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsfStager();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.File, () => message.File = dependency_1.commonpb.File.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsfStager {
            return MsfStager.deserialize(bytes);
        }
    }
    export class GetSystemReq extends pb_1.Message {
        constructor(data?: any[] | {
            HostingProcess?: string;
            Config?: ImplantConfig;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("HostingProcess" in data && data.HostingProcess != undefined) {
                    this.HostingProcess = data.HostingProcess;
                }
                if ("Config" in data && data.Config != undefined) {
                    this.Config = data.Config;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get HostingProcess() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set HostingProcess(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Config() {
            return pb_1.Message.getWrapperField(this, ImplantConfig, 2) as ImplantConfig;
        }
        set Config(value: ImplantConfig) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            HostingProcess?: string;
            Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new GetSystemReq({});
            if (data.HostingProcess != null) {
                message.HostingProcess = data.HostingProcess;
            }
            if (data.Config != null) {
                message.Config = ImplantConfig.fromObject(data.Config);
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                HostingProcess?: string;
                Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.HostingProcess != null) {
                data.HostingProcess = this.HostingProcess;
            }
            if (this.Config != null) {
                data.Config = this.Config.toObject();
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.HostingProcess === "string" && this.HostingProcess.length)
                writer.writeString(1, this.HostingProcess);
            if (this.Config !== undefined)
                writer.writeMessage(2, this.Config, () => this.Config.serialize(writer));
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetSystemReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetSystemReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.HostingProcess = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Config, () => message.Config = ImplantConfig.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetSystemReq {
            return GetSystemReq.deserialize(bytes);
        }
    }
    export class MigrateReq extends pb_1.Message {
        constructor(data?: any[] | {
            Pid?: number;
            Config?: ImplantConfig;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Pid" in data && data.Pid != undefined) {
                    this.Pid = data.Pid;
                }
                if ("Config" in data && data.Config != undefined) {
                    this.Config = data.Config;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Pid() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set Pid(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Config() {
            return pb_1.Message.getWrapperField(this, ImplantConfig, 2) as ImplantConfig;
        }
        set Config(value: ImplantConfig) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Pid?: number;
            Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new MigrateReq({});
            if (data.Pid != null) {
                message.Pid = data.Pid;
            }
            if (data.Config != null) {
                message.Config = ImplantConfig.fromObject(data.Config);
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Pid?: number;
                Config?: ReturnType<typeof ImplantConfig.prototype.toObject>;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Pid != null) {
                data.Pid = this.Pid;
            }
            if (this.Config != null) {
                data.Config = this.Config.toObject();
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Pid !== undefined)
                writer.writeUint32(1, this.Pid);
            if (this.Config !== undefined)
                writer.writeMessage(2, this.Config, () => this.Config.serialize(writer));
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MigrateReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MigrateReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Pid = reader.readUint32();
                        break;
                    case 2:
                        reader.readMessage(message.Config, () => message.Config = ImplantConfig.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MigrateReq {
            return MigrateReq.deserialize(bytes);
        }
    }
    export class CreateTunnelReq extends pb_1.Message {
        constructor(data?: any[] | {
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new CreateTunnelReq({});
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateTunnelReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateTunnelReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateTunnelReq {
            return CreateTunnelReq.deserialize(bytes);
        }
    }
    export class CreateTunnel extends pb_1.Message {
        constructor(data?: any[] | {
            SessionID?: number;
            TunnelID?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("SessionID" in data && data.SessionID != undefined) {
                    this.SessionID = data.SessionID;
                }
                if ("TunnelID" in data && data.TunnelID != undefined) {
                    this.TunnelID = data.TunnelID;
                }
            }
        }
        get SessionID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set SessionID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get TunnelID() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set TunnelID(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            SessionID?: number;
            TunnelID?: string;
        }) {
            const message = new CreateTunnel({});
            if (data.SessionID != null) {
                message.SessionID = data.SessionID;
            }
            if (data.TunnelID != null) {
                message.TunnelID = data.TunnelID;
            }
            return message;
        }
        toObject() {
            const data: {
                SessionID?: number;
                TunnelID?: string;
            } = {};
            if (this.SessionID != null) {
                data.SessionID = this.SessionID;
            }
            if (this.TunnelID != null) {
                data.TunnelID = this.TunnelID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.SessionID !== undefined)
                writer.writeUint32(1, this.SessionID);
            if (this.TunnelID !== undefined)
                writer.writeUint64String(8, this.TunnelID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateTunnel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateTunnel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.SessionID = reader.readUint32();
                        break;
                    case 8:
                        message.TunnelID = reader.readUint64String();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateTunnel {
            return CreateTunnel.deserialize(bytes);
        }
    }
    export class CloseTunnelReq extends pb_1.Message {
        constructor(data?: any[] | {
            TunnelID?: string;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("TunnelID" in data && data.TunnelID != undefined) {
                    this.TunnelID = data.TunnelID;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get TunnelID() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set TunnelID(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            TunnelID?: string;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new CloseTunnelReq({});
            if (data.TunnelID != null) {
                message.TunnelID = data.TunnelID;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                TunnelID?: string;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.TunnelID != null) {
                data.TunnelID = this.TunnelID;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.TunnelID !== undefined)
                writer.writeUint64String(8, this.TunnelID);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CloseTunnelReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CloseTunnelReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 8:
                        message.TunnelID = reader.readUint64String();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CloseTunnelReq {
            return CloseTunnelReq.deserialize(bytes);
        }
    }
    export class PivotGraphEntry extends pb_1.Message {
        constructor(data?: any[] | {
            PeerID?: number;
            Session?: Session;
            Name?: string;
            Children?: PivotGraphEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("PeerID" in data && data.PeerID != undefined) {
                    this.PeerID = data.PeerID;
                }
                if ("Session" in data && data.Session != undefined) {
                    this.Session = data.Session;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Children" in data && data.Children != undefined) {
                    this.Children = data.Children;
                }
            }
        }
        get PeerID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set PeerID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Session() {
            return pb_1.Message.getWrapperField(this, Session, 2) as Session;
        }
        set Session(value: Session) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Children() {
            return pb_1.Message.getRepeatedWrapperField(this, PivotGraphEntry, 4) as PivotGraphEntry[];
        }
        set Children(value: PivotGraphEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            PeerID?: number;
            Session?: ReturnType<typeof Session.prototype.toObject>;
            Name?: string;
            Children?: ReturnType<typeof PivotGraphEntry.prototype.toObject>[];
        }) {
            const message = new PivotGraphEntry({});
            if (data.PeerID != null) {
                message.PeerID = data.PeerID;
            }
            if (data.Session != null) {
                message.Session = Session.fromObject(data.Session);
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Children != null) {
                message.Children = data.Children.map(item => PivotGraphEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                PeerID?: number;
                Session?: ReturnType<typeof Session.prototype.toObject>;
                Name?: string;
                Children?: ReturnType<typeof PivotGraphEntry.prototype.toObject>[];
            } = {};
            if (this.PeerID != null) {
                data.PeerID = this.PeerID;
            }
            if (this.Session != null) {
                data.Session = this.Session.toObject();
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Children != null) {
                data.Children = this.Children.map((item: PivotGraphEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.PeerID !== undefined)
                writer.writeInt64(1, this.PeerID);
            if (this.Session !== undefined)
                writer.writeMessage(2, this.Session, () => this.Session.serialize(writer));
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(3, this.Name);
            if (this.Children !== undefined)
                writer.writeRepeatedMessage(4, this.Children, (item: PivotGraphEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PivotGraphEntry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PivotGraphEntry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.PeerID = reader.readInt64();
                        break;
                    case 2:
                        reader.readMessage(message.Session, () => message.Session = Session.deserialize(reader));
                        break;
                    case 3:
                        message.Name = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.Children, () => pb_1.Message.addToRepeatedWrapperField(message, 4, PivotGraphEntry.deserialize(reader), PivotGraphEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PivotGraphEntry {
            return PivotGraphEntry.deserialize(bytes);
        }
    }
    export class PivotGraph extends pb_1.Message {
        constructor(data?: any[] | {
            Children?: PivotGraphEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Children" in data && data.Children != undefined) {
                    this.Children = data.Children;
                }
            }
        }
        get Children() {
            return pb_1.Message.getRepeatedWrapperField(this, PivotGraphEntry, 1) as PivotGraphEntry[];
        }
        set Children(value: PivotGraphEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Children?: ReturnType<typeof PivotGraphEntry.prototype.toObject>[];
        }) {
            const message = new PivotGraph({});
            if (data.Children != null) {
                message.Children = data.Children.map(item => PivotGraphEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Children?: ReturnType<typeof PivotGraphEntry.prototype.toObject>[];
            } = {};
            if (this.Children != null) {
                data.Children = this.Children.map((item: PivotGraphEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Children !== undefined)
                writer.writeRepeatedMessage(1, this.Children, (item: PivotGraphEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PivotGraph {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PivotGraph();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Children, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PivotGraphEntry.deserialize(reader), PivotGraphEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PivotGraph {
            return PivotGraph.deserialize(bytes);
        }
    }
    export class Client extends pb_1.Message {
        constructor(data?: any[] | {
            ID?: number;
            Name?: string;
            Operator?: Operator;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Operator" in data && data.Operator != undefined) {
                    this.Operator = data.Operator;
                }
            }
        }
        get ID() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set ID(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Operator() {
            return pb_1.Message.getWrapperField(this, Operator, 3) as Operator;
        }
        set Operator(value: Operator) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            ID?: number;
            Name?: string;
            Operator?: ReturnType<typeof Operator.prototype.toObject>;
        }) {
            const message = new Client({});
            if (data.ID != null) {
                message.ID = data.ID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Operator != null) {
                message.Operator = Operator.fromObject(data.Operator);
            }
            return message;
        }
        toObject() {
            const data: {
                ID?: number;
                Name?: string;
                Operator?: ReturnType<typeof Operator.prototype.toObject>;
            } = {};
            if (this.ID != null) {
                data.ID = this.ID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Operator != null) {
                data.Operator = this.Operator.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ID !== undefined)
                writer.writeUint32(1, this.ID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(2, this.Name);
            if (this.Operator !== undefined)
                writer.writeMessage(3, this.Operator, () => this.Operator.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Client {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Client();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ID = reader.readUint32();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.Operator, () => message.Operator = Operator.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Client {
            return Client.deserialize(bytes);
        }
    }
    export class Event extends pb_1.Message {
        constructor(data?: any[] | {
            EventType?: string;
            Session?: Session;
            Job?: Job;
            Client?: Client;
            Data?: Uint8Array;
            Err?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("EventType" in data && data.EventType != undefined) {
                    this.EventType = data.EventType;
                }
                if ("Session" in data && data.Session != undefined) {
                    this.Session = data.Session;
                }
                if ("Job" in data && data.Job != undefined) {
                    this.Job = data.Job;
                }
                if ("Client" in data && data.Client != undefined) {
                    this.Client = data.Client;
                }
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
                if ("Err" in data && data.Err != undefined) {
                    this.Err = data.Err;
                }
            }
        }
        get EventType() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set EventType(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Session() {
            return pb_1.Message.getWrapperField(this, Session, 2) as Session;
        }
        set Session(value: Session) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get Job() {
            return pb_1.Message.getWrapperField(this, Job, 3) as Job;
        }
        set Job(value: Job) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get Client() {
            return pb_1.Message.getWrapperField(this, Client, 4) as Client;
        }
        set Client(value: Client) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get Data() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get Err() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set Err(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            EventType?: string;
            Session?: ReturnType<typeof Session.prototype.toObject>;
            Job?: ReturnType<typeof Job.prototype.toObject>;
            Client?: ReturnType<typeof Client.prototype.toObject>;
            Data?: Uint8Array;
            Err?: string;
        }) {
            const message = new Event({});
            if (data.EventType != null) {
                message.EventType = data.EventType;
            }
            if (data.Session != null) {
                message.Session = Session.fromObject(data.Session);
            }
            if (data.Job != null) {
                message.Job = Job.fromObject(data.Job);
            }
            if (data.Client != null) {
                message.Client = Client.fromObject(data.Client);
            }
            if (data.Data != null) {
                message.Data = data.Data;
            }
            if (data.Err != null) {
                message.Err = data.Err;
            }
            return message;
        }
        toObject() {
            const data: {
                EventType?: string;
                Session?: ReturnType<typeof Session.prototype.toObject>;
                Job?: ReturnType<typeof Job.prototype.toObject>;
                Client?: ReturnType<typeof Client.prototype.toObject>;
                Data?: Uint8Array;
                Err?: string;
            } = {};
            if (this.EventType != null) {
                data.EventType = this.EventType;
            }
            if (this.Session != null) {
                data.Session = this.Session.toObject();
            }
            if (this.Job != null) {
                data.Job = this.Job.toObject();
            }
            if (this.Client != null) {
                data.Client = this.Client.toObject();
            }
            if (this.Data != null) {
                data.Data = this.Data;
            }
            if (this.Err != null) {
                data.Err = this.Err;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.EventType === "string" && this.EventType.length)
                writer.writeString(1, this.EventType);
            if (this.Session !== undefined)
                writer.writeMessage(2, this.Session, () => this.Session.serialize(writer));
            if (this.Job !== undefined)
                writer.writeMessage(3, this.Job, () => this.Job.serialize(writer));
            if (this.Client !== undefined)
                writer.writeMessage(4, this.Client, () => this.Client.serialize(writer));
            if (this.Data !== undefined)
                writer.writeBytes(5, this.Data);
            if (typeof this.Err === "string" && this.Err.length)
                writer.writeString(6, this.Err);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.EventType = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Session, () => message.Session = Session.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.Job, () => message.Job = Job.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.Client, () => message.Client = Client.deserialize(reader));
                        break;
                    case 5:
                        message.Data = reader.readBytes();
                        break;
                    case 6:
                        message.Err = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Event {
            return Event.deserialize(bytes);
        }
    }
    export class Operators extends pb_1.Message {
        constructor(data?: any[] | {
            Operators?: Operator[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Operators" in data && data.Operators != undefined) {
                    this.Operators = data.Operators;
                }
            }
        }
        get Operators() {
            return pb_1.Message.getRepeatedWrapperField(this, Operator, 1) as Operator[];
        }
        set Operators(value: Operator[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Operators?: ReturnType<typeof Operator.prototype.toObject>[];
        }) {
            const message = new Operators({});
            if (data.Operators != null) {
                message.Operators = data.Operators.map(item => Operator.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Operators?: ReturnType<typeof Operator.prototype.toObject>[];
            } = {};
            if (this.Operators != null) {
                data.Operators = this.Operators.map((item: Operator) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Operators !== undefined)
                writer.writeRepeatedMessage(1, this.Operators, (item: Operator) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Operators {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Operators();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Operators, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Operator.deserialize(reader), Operator));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Operators {
            return Operators.deserialize(bytes);
        }
    }
    export class Operator extends pb_1.Message {
        constructor(data?: any[] | {
            Online?: boolean;
            Name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Online" in data && data.Online != undefined) {
                    this.Online = data.Online;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
            }
        }
        get Online() {
            return pb_1.Message.getField(this, 1) as boolean;
        }
        set Online(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            Online?: boolean;
            Name?: string;
        }) {
            const message = new Operator({});
            if (data.Online != null) {
                message.Online = data.Online;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            return message;
        }
        toObject() {
            const data: {
                Online?: boolean;
                Name?: string;
            } = {};
            if (this.Online != null) {
                data.Online = this.Online;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Online !== undefined)
                writer.writeBool(1, this.Online);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(2, this.Name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Operator {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Operator();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Online = reader.readBool();
                        break;
                    case 2:
                        message.Name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Operator {
            return Operator.deserialize(bytes);
        }
    }
    export class WebContent extends pb_1.Message {
        constructor(data?: any[] | {
            Path?: string;
            ContentType?: string;
            Size?: string;
            Content?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Path" in data && data.Path != undefined) {
                    this.Path = data.Path;
                }
                if ("ContentType" in data && data.ContentType != undefined) {
                    this.ContentType = data.ContentType;
                }
                if ("Size" in data && data.Size != undefined) {
                    this.Size = data.Size;
                }
                if ("Content" in data && data.Content != undefined) {
                    this.Content = data.Content;
                }
            }
        }
        get Path() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ContentType() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set ContentType(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Size() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Size(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Content() {
            return pb_1.Message.getField(this, 9) as Uint8Array;
        }
        set Content(value: Uint8Array) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            Path?: string;
            ContentType?: string;
            Size?: string;
            Content?: Uint8Array;
        }) {
            const message = new WebContent({});
            if (data.Path != null) {
                message.Path = data.Path;
            }
            if (data.ContentType != null) {
                message.ContentType = data.ContentType;
            }
            if (data.Size != null) {
                message.Size = data.Size;
            }
            if (data.Content != null) {
                message.Content = data.Content;
            }
            return message;
        }
        toObject() {
            const data: {
                Path?: string;
                ContentType?: string;
                Size?: string;
                Content?: Uint8Array;
            } = {};
            if (this.Path != null) {
                data.Path = this.Path;
            }
            if (this.ContentType != null) {
                data.ContentType = this.ContentType;
            }
            if (this.Size != null) {
                data.Size = this.Size;
            }
            if (this.Content != null) {
                data.Content = this.Content;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Path === "string" && this.Path.length)
                writer.writeString(1, this.Path);
            if (typeof this.ContentType === "string" && this.ContentType.length)
                writer.writeString(2, this.ContentType);
            if (this.Size !== undefined)
                writer.writeUint64String(3, this.Size);
            if (this.Content !== undefined)
                writer.writeBytes(9, this.Content);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebContent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebContent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Path = reader.readString();
                        break;
                    case 2:
                        message.ContentType = reader.readString();
                        break;
                    case 3:
                        message.Size = reader.readUint64String();
                        break;
                    case 9:
                        message.Content = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WebContent {
            return WebContent.deserialize(bytes);
        }
    }
    export class WebsiteAddContent extends pb_1.Message {
        constructor(data?: any[] | {
            Name?: string;
            Contents?: Map<string, WebContent>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Contents" in data && data.Contents != undefined) {
                    this.Contents = data.Contents;
                }
            }
            if (!this.Contents)
                this.Contents = new Map();
        }
        get Name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Contents() {
            return pb_1.Message.getField(this, 2) as any as Map<string, WebContent>;
        }
        set Contents(value: Map<string, WebContent>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        static fromObject(data: {
            Name?: string;
            Contents?: {
                [key: string]: ReturnType<typeof WebContent.prototype.toObject>;
            };
        }) {
            const message = new WebsiteAddContent({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (typeof data.Contents == "object") {
                message.Contents = new Map(Object.entries(data.Contents).map(([key, value]) => [key, WebContent.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
                Contents?: {
                    [key: string]: ReturnType<typeof WebContent.prototype.toObject>;
                };
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Contents.size > 0) {
                data.Contents = Object.fromEntries(Array.from(this.Contents).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(1, this.Name);
            for (const [key, value] of this.Contents) {
                writer.writeMessage(2, this.Contents, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebsiteAddContent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebsiteAddContent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Contents as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = WebContent.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WebsiteAddContent {
            return WebsiteAddContent.deserialize(bytes);
        }
    }
    export class WebsiteRemoveContent extends pb_1.Message {
        constructor(data?: any[] | {
            Name?: string;
            Paths?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Paths" in data && data.Paths != undefined) {
                    this.Paths = data.Paths;
                }
            }
        }
        get Name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Paths() {
            return pb_1.Message.getField(this, 2) as string[];
        }
        set Paths(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            Name?: string;
            Paths?: string[];
        }) {
            const message = new WebsiteRemoveContent({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Paths != null) {
                message.Paths = data.Paths;
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
                Paths?: string[];
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Paths != null) {
                data.Paths = this.Paths;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(1, this.Name);
            if (this.Paths !== undefined)
                writer.writeRepeatedString(2, this.Paths);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebsiteRemoveContent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebsiteRemoveContent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WebsiteRemoveContent {
            return WebsiteRemoveContent.deserialize(bytes);
        }
    }
    export class Website extends pb_1.Message {
        constructor(data?: any[] | {
            Name?: string;
            Contents?: Map<string, WebContent>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Contents" in data && data.Contents != undefined) {
                    this.Contents = data.Contents;
                }
            }
            if (!this.Contents)
                this.Contents = new Map();
        }
        get Name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Contents() {
            return pb_1.Message.getField(this, 2) as any as Map<string, WebContent>;
        }
        set Contents(value: Map<string, WebContent>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        static fromObject(data: {
            Name?: string;
            Contents?: {
                [key: string]: ReturnType<typeof WebContent.prototype.toObject>;
            };
        }) {
            const message = new Website({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (typeof data.Contents == "object") {
                message.Contents = new Map(Object.entries(data.Contents).map(([key, value]) => [key, WebContent.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
                Contents?: {
                    [key: string]: ReturnType<typeof WebContent.prototype.toObject>;
                };
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Contents.size > 0) {
                data.Contents = Object.fromEntries(Array.from(this.Contents).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(1, this.Name);
            for (const [key, value] of this.Contents) {
                writer.writeMessage(2, this.Contents, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Website {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Website();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Contents as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = WebContent.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Website {
            return Website.deserialize(bytes);
        }
    }
    export class Websites extends pb_1.Message {
        constructor(data?: any[] | {
            Websites?: Website[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Websites" in data && data.Websites != undefined) {
                    this.Websites = data.Websites;
                }
            }
        }
        get Websites() {
            return pb_1.Message.getRepeatedWrapperField(this, Website, 1) as Website[];
        }
        set Websites(value: Website[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Websites?: ReturnType<typeof Website.prototype.toObject>[];
        }) {
            const message = new Websites({});
            if (data.Websites != null) {
                message.Websites = data.Websites.map(item => Website.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Websites?: ReturnType<typeof Website.prototype.toObject>[];
            } = {};
            if (this.Websites != null) {
                data.Websites = this.Websites.map((item: Website) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Websites !== undefined)
                writer.writeRepeatedMessage(1, this.Websites, (item: Website) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Websites {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Websites();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Websites, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Website.deserialize(reader), Website));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Websites {
            return Websites.deserialize(bytes);
        }
    }
    export class WGClientConfig extends pb_1.Message {
        constructor(data?: any[] | {
            ServerPubKey?: string;
            ClientPrivateKey?: string;
            ClientPubKey?: string;
            ClientIP?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ServerPubKey" in data && data.ServerPubKey != undefined) {
                    this.ServerPubKey = data.ServerPubKey;
                }
                if ("ClientPrivateKey" in data && data.ClientPrivateKey != undefined) {
                    this.ClientPrivateKey = data.ClientPrivateKey;
                }
                if ("ClientPubKey" in data && data.ClientPubKey != undefined) {
                    this.ClientPubKey = data.ClientPubKey;
                }
                if ("ClientIP" in data && data.ClientIP != undefined) {
                    this.ClientIP = data.ClientIP;
                }
            }
        }
        get ServerPubKey() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ServerPubKey(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientPrivateKey() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set ClientPrivateKey(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get ClientPubKey() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set ClientPubKey(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get ClientIP() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set ClientIP(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            ServerPubKey?: string;
            ClientPrivateKey?: string;
            ClientPubKey?: string;
            ClientIP?: string;
        }) {
            const message = new WGClientConfig({});
            if (data.ServerPubKey != null) {
                message.ServerPubKey = data.ServerPubKey;
            }
            if (data.ClientPrivateKey != null) {
                message.ClientPrivateKey = data.ClientPrivateKey;
            }
            if (data.ClientPubKey != null) {
                message.ClientPubKey = data.ClientPubKey;
            }
            if (data.ClientIP != null) {
                message.ClientIP = data.ClientIP;
            }
            return message;
        }
        toObject() {
            const data: {
                ServerPubKey?: string;
                ClientPrivateKey?: string;
                ClientPubKey?: string;
                ClientIP?: string;
            } = {};
            if (this.ServerPubKey != null) {
                data.ServerPubKey = this.ServerPubKey;
            }
            if (this.ClientPrivateKey != null) {
                data.ClientPrivateKey = this.ClientPrivateKey;
            }
            if (this.ClientPubKey != null) {
                data.ClientPubKey = this.ClientPubKey;
            }
            if (this.ClientIP != null) {
                data.ClientIP = this.ClientIP;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ServerPubKey === "string" && this.ServerPubKey.length)
                writer.writeString(1, this.ServerPubKey);
            if (typeof this.ClientPrivateKey === "string" && this.ClientPrivateKey.length)
                writer.writeString(2, this.ClientPrivateKey);
            if (typeof this.ClientPubKey === "string" && this.ClientPubKey.length)
                writer.writeString(3, this.ClientPubKey);
            if (typeof this.ClientIP === "string" && this.ClientIP.length)
                writer.writeString(4, this.ClientIP);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WGClientConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WGClientConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ServerPubKey = reader.readString();
                        break;
                    case 2:
                        message.ClientPrivateKey = reader.readString();
                        break;
                    case 3:
                        message.ClientPubKey = reader.readString();
                        break;
                    case 4:
                        message.ClientIP = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WGClientConfig {
            return WGClientConfig.deserialize(bytes);
        }
    }
    export class Credential extends pb_1.Message {
        constructor(data?: any[] | {
            User?: string;
            Password?: string;
            APIKey?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("User" in data && data.User != undefined) {
                    this.User = data.User;
                }
                if ("Password" in data && data.Password != undefined) {
                    this.Password = data.Password;
                }
                if ("APIKey" in data && data.APIKey != undefined) {
                    this.APIKey = data.APIKey;
                }
            }
        }
        get User() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set User(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Password() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Password(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get APIKey() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set APIKey(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            User?: string;
            Password?: string;
            APIKey?: string;
        }) {
            const message = new Credential({});
            if (data.User != null) {
                message.User = data.User;
            }
            if (data.Password != null) {
                message.Password = data.Password;
            }
            if (data.APIKey != null) {
                message.APIKey = data.APIKey;
            }
            return message;
        }
        toObject() {
            const data: {
                User?: string;
                Password?: string;
                APIKey?: string;
            } = {};
            if (this.User != null) {
                data.User = this.User;
            }
            if (this.Password != null) {
                data.Password = this.Password;
            }
            if (this.APIKey != null) {
                data.APIKey = this.APIKey;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.User === "string" && this.User.length)
                writer.writeString(2, this.User);
            if (typeof this.Password === "string" && this.Password.length)
                writer.writeString(3, this.Password);
            if (typeof this.APIKey === "string" && this.APIKey.length)
                writer.writeString(4, this.APIKey);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Credential {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Credential();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.User = reader.readString();
                        break;
                    case 3:
                        message.Password = reader.readString();
                        break;
                    case 4:
                        message.APIKey = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Credential {
            return Credential.deserialize(bytes);
        }
    }
    export class Loot extends pb_1.Message {
        constructor(data?: any[] | {
            Type?: LootType;
            LootID?: string;
            Name?: string;
            CredentialType?: CredentialType;
            Credential?: Credential;
            FileType?: FileType;
            File?: dependency_1.commonpb.File;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Type" in data && data.Type != undefined) {
                    this.Type = data.Type;
                }
                if ("LootID" in data && data.LootID != undefined) {
                    this.LootID = data.LootID;
                }
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("CredentialType" in data && data.CredentialType != undefined) {
                    this.CredentialType = data.CredentialType;
                }
                if ("Credential" in data && data.Credential != undefined) {
                    this.Credential = data.Credential;
                }
                if ("FileType" in data && data.FileType != undefined) {
                    this.FileType = data.FileType;
                }
                if ("File" in data && data.File != undefined) {
                    this.File = data.File;
                }
            }
        }
        get Type() {
            return pb_1.Message.getField(this, 1) as LootType;
        }
        set Type(value: LootType) {
            pb_1.Message.setField(this, 1, value);
        }
        get LootID() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set LootID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Name() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get CredentialType() {
            return pb_1.Message.getField(this, 4) as CredentialType;
        }
        set CredentialType(value: CredentialType) {
            pb_1.Message.setField(this, 4, value);
        }
        get Credential() {
            return pb_1.Message.getWrapperField(this, Credential, 5) as Credential;
        }
        set Credential(value: Credential) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get FileType() {
            return pb_1.Message.getField(this, 6) as FileType;
        }
        set FileType(value: FileType) {
            pb_1.Message.setField(this, 6, value);
        }
        get File() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.File, 9) as dependency_1.commonpb.File;
        }
        set File(value: dependency_1.commonpb.File) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Type?: LootType;
            LootID?: string;
            Name?: string;
            CredentialType?: CredentialType;
            Credential?: ReturnType<typeof Credential.prototype.toObject>;
            FileType?: FileType;
            File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
        }) {
            const message = new Loot({});
            if (data.Type != null) {
                message.Type = data.Type;
            }
            if (data.LootID != null) {
                message.LootID = data.LootID;
            }
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.CredentialType != null) {
                message.CredentialType = data.CredentialType;
            }
            if (data.Credential != null) {
                message.Credential = Credential.fromObject(data.Credential);
            }
            if (data.FileType != null) {
                message.FileType = data.FileType;
            }
            if (data.File != null) {
                message.File = dependency_1.commonpb.File.fromObject(data.File);
            }
            return message;
        }
        toObject() {
            const data: {
                Type?: LootType;
                LootID?: string;
                Name?: string;
                CredentialType?: CredentialType;
                Credential?: ReturnType<typeof Credential.prototype.toObject>;
                FileType?: FileType;
                File?: ReturnType<typeof dependency_1.commonpb.File.prototype.toObject>;
            } = {};
            if (this.Type != null) {
                data.Type = this.Type;
            }
            if (this.LootID != null) {
                data.LootID = this.LootID;
            }
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.CredentialType != null) {
                data.CredentialType = this.CredentialType;
            }
            if (this.Credential != null) {
                data.Credential = this.Credential.toObject();
            }
            if (this.FileType != null) {
                data.FileType = this.FileType;
            }
            if (this.File != null) {
                data.File = this.File.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Type !== undefined)
                writer.writeEnum(1, this.Type);
            if (typeof this.LootID === "string" && this.LootID.length)
                writer.writeString(2, this.LootID);
            if (typeof this.Name === "string" && this.Name.length)
                writer.writeString(3, this.Name);
            if (this.CredentialType !== undefined)
                writer.writeEnum(4, this.CredentialType);
            if (this.Credential !== undefined)
                writer.writeMessage(5, this.Credential, () => this.Credential.serialize(writer));
            if (this.FileType !== undefined)
                writer.writeEnum(6, this.FileType);
            if (this.File !== undefined)
                writer.writeMessage(9, this.File, () => this.File.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Loot {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Loot();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Type = reader.readEnum();
                        break;
                    case 2:
                        message.LootID = reader.readString();
                        break;
                    case 3:
                        message.Name = reader.readString();
                        break;
                    case 4:
                        message.CredentialType = reader.readEnum();
                        break;
                    case 5:
                        reader.readMessage(message.Credential, () => message.Credential = Credential.deserialize(reader));
                        break;
                    case 6:
                        message.FileType = reader.readEnum();
                        break;
                    case 9:
                        reader.readMessage(message.File, () => message.File = dependency_1.commonpb.File.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Loot {
            return Loot.deserialize(bytes);
        }
    }
    export class AllLoot extends pb_1.Message {
        constructor(data?: any[] | {
            Loot?: Loot[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Loot" in data && data.Loot != undefined) {
                    this.Loot = data.Loot;
                }
            }
        }
        get Loot() {
            return pb_1.Message.getRepeatedWrapperField(this, Loot, 1) as Loot[];
        }
        set Loot(value: Loot[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Loot?: ReturnType<typeof Loot.prototype.toObject>[];
        }) {
            const message = new AllLoot({});
            if (data.Loot != null) {
                message.Loot = data.Loot.map(item => Loot.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Loot?: ReturnType<typeof Loot.prototype.toObject>[];
            } = {};
            if (this.Loot != null) {
                data.Loot = this.Loot.map((item: Loot) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Loot !== undefined)
                writer.writeRepeatedMessage(1, this.Loot, (item: Loot) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllLoot {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllLoot();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Loot, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Loot.deserialize(reader), Loot));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AllLoot {
            return AllLoot.deserialize(bytes);
        }
    }
    export class IOC extends pb_1.Message {
        constructor(data?: any[] | {
            Path?: string;
            FileHash?: string;
            ID?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Path" in data && data.Path != undefined) {
                    this.Path = data.Path;
                }
                if ("FileHash" in data && data.FileHash != undefined) {
                    this.FileHash = data.FileHash;
                }
                if ("ID" in data && data.ID != undefined) {
                    this.ID = data.ID;
                }
            }
        }
        get Path() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get FileHash() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set FileHash(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get ID() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set ID(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            Path?: string;
            FileHash?: string;
            ID?: string;
        }) {
            const message = new IOC({});
            if (data.Path != null) {
                message.Path = data.Path;
            }
            if (data.FileHash != null) {
                message.FileHash = data.FileHash;
            }
            if (data.ID != null) {
                message.ID = data.ID;
            }
            return message;
        }
        toObject() {
            const data: {
                Path?: string;
                FileHash?: string;
                ID?: string;
            } = {};
            if (this.Path != null) {
                data.Path = this.Path;
            }
            if (this.FileHash != null) {
                data.FileHash = this.FileHash;
            }
            if (this.ID != null) {
                data.ID = this.ID;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Path === "string" && this.Path.length)
                writer.writeString(1, this.Path);
            if (typeof this.FileHash === "string" && this.FileHash.length)
                writer.writeString(2, this.FileHash);
            if (typeof this.ID === "string" && this.ID.length)
                writer.writeString(3, this.ID);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IOC {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IOC();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Path = reader.readString();
                        break;
                    case 2:
                        message.FileHash = reader.readString();
                        break;
                    case 3:
                        message.ID = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IOC {
            return IOC.deserialize(bytes);
        }
    }
    export class ExtensionData extends pb_1.Message {
        constructor(data?: any[] | {
            Output?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Output" in data && data.Output != undefined) {
                    this.Output = data.Output;
                }
            }
        }
        get Output() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Output(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            Output?: string;
        }) {
            const message = new ExtensionData({});
            if (data.Output != null) {
                message.Output = data.Output;
            }
            return message;
        }
        toObject() {
            const data: {
                Output?: string;
            } = {};
            if (this.Output != null) {
                data.Output = this.Output;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Output === "string" && this.Output.length)
                writer.writeString(1, this.Output);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExtensionData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExtensionData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Output = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExtensionData {
            return ExtensionData.deserialize(bytes);
        }
    }
    export class Host extends pb_1.Message {
        constructor(data?: any[] | {
            Hostname?: string;
            HostUUID?: string;
            OSVersion?: string;
            IOCs?: IOC[];
            ExtensionData?: Map<string, ExtensionData>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Hostname" in data && data.Hostname != undefined) {
                    this.Hostname = data.Hostname;
                }
                if ("HostUUID" in data && data.HostUUID != undefined) {
                    this.HostUUID = data.HostUUID;
                }
                if ("OSVersion" in data && data.OSVersion != undefined) {
                    this.OSVersion = data.OSVersion;
                }
                if ("IOCs" in data && data.IOCs != undefined) {
                    this.IOCs = data.IOCs;
                }
                if ("ExtensionData" in data && data.ExtensionData != undefined) {
                    this.ExtensionData = data.ExtensionData;
                }
            }
            if (!this.ExtensionData)
                this.ExtensionData = new Map();
        }
        get Hostname() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set Hostname(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get HostUUID() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set HostUUID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get OSVersion() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set OSVersion(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get IOCs() {
            return pb_1.Message.getRepeatedWrapperField(this, IOC, 4) as IOC[];
        }
        set IOCs(value: IOC[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get ExtensionData() {
            return pb_1.Message.getField(this, 5) as any as Map<string, ExtensionData>;
        }
        set ExtensionData(value: Map<string, ExtensionData>) {
            pb_1.Message.setField(this, 5, value as any);
        }
        static fromObject(data: {
            Hostname?: string;
            HostUUID?: string;
            OSVersion?: string;
            IOCs?: ReturnType<typeof IOC.prototype.toObject>[];
            ExtensionData?: {
                [key: string]: ReturnType<typeof ExtensionData.prototype.toObject>;
            };
        }) {
            const message = new Host({});
            if (data.Hostname != null) {
                message.Hostname = data.Hostname;
            }
            if (data.HostUUID != null) {
                message.HostUUID = data.HostUUID;
            }
            if (data.OSVersion != null) {
                message.OSVersion = data.OSVersion;
            }
            if (data.IOCs != null) {
                message.IOCs = data.IOCs.map(item => IOC.fromObject(item));
            }
            if (typeof data.ExtensionData == "object") {
                message.ExtensionData = new Map(Object.entries(data.ExtensionData).map(([key, value]) => [key, ExtensionData.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                Hostname?: string;
                HostUUID?: string;
                OSVersion?: string;
                IOCs?: ReturnType<typeof IOC.prototype.toObject>[];
                ExtensionData?: {
                    [key: string]: ReturnType<typeof ExtensionData.prototype.toObject>;
                };
            } = {};
            if (this.Hostname != null) {
                data.Hostname = this.Hostname;
            }
            if (this.HostUUID != null) {
                data.HostUUID = this.HostUUID;
            }
            if (this.OSVersion != null) {
                data.OSVersion = this.OSVersion;
            }
            if (this.IOCs != null) {
                data.IOCs = this.IOCs.map((item: IOC) => item.toObject());
            }
            if (this.ExtensionData.size > 0) {
                data.ExtensionData = Object.fromEntries(Array.from(this.ExtensionData).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.Hostname === "string" && this.Hostname.length)
                writer.writeString(1, this.Hostname);
            if (typeof this.HostUUID === "string" && this.HostUUID.length)
                writer.writeString(2, this.HostUUID);
            if (typeof this.OSVersion === "string" && this.OSVersion.length)
                writer.writeString(3, this.OSVersion);
            if (this.IOCs !== undefined)
                writer.writeRepeatedMessage(4, this.IOCs, (item: IOC) => item.serialize(writer));
            for (const [key, value] of this.ExtensionData) {
                writer.writeMessage(5, this.ExtensionData, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Host {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Host();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Hostname = reader.readString();
                        break;
                    case 2:
                        message.HostUUID = reader.readString();
                        break;
                    case 3:
                        message.OSVersion = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.IOCs, () => pb_1.Message.addToRepeatedWrapperField(message, 4, IOC.deserialize(reader), IOC));
                        break;
                    case 5:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.ExtensionData as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = ExtensionData.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Host {
            return Host.deserialize(bytes);
        }
    }
    export class AllHosts extends pb_1.Message {
        constructor(data?: any[] | {
            Hosts?: Host[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Hosts" in data && data.Hosts != undefined) {
                    this.Hosts = data.Hosts;
                }
            }
        }
        get Hosts() {
            return pb_1.Message.getRepeatedWrapperField(this, Host, 1) as Host[];
        }
        set Hosts(value: Host[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            Hosts?: ReturnType<typeof Host.prototype.toObject>[];
        }) {
            const message = new AllHosts({});
            if (data.Hosts != null) {
                message.Hosts = data.Hosts.map(item => Host.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                Hosts?: ReturnType<typeof Host.prototype.toObject>[];
            } = {};
            if (this.Hosts != null) {
                data.Hosts = this.Hosts.map((item: Host) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Hosts !== undefined)
                writer.writeRepeatedMessage(1, this.Hosts, (item: Host) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllHosts {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllHosts();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.Hosts, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Host.deserialize(reader), Host));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AllHosts {
            return AllHosts.deserialize(bytes);
        }
    }
    export class DllHijackReq extends pb_1.Message {
        constructor(data?: any[] | {
            ReferenceDLLPath?: string;
            TargetLocation?: string;
            ReferenceDLL?: Uint8Array;
            TargetDLL?: Uint8Array;
            ProfileName?: string;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ReferenceDLLPath" in data && data.ReferenceDLLPath != undefined) {
                    this.ReferenceDLLPath = data.ReferenceDLLPath;
                }
                if ("TargetLocation" in data && data.TargetLocation != undefined) {
                    this.TargetLocation = data.TargetLocation;
                }
                if ("ReferenceDLL" in data && data.ReferenceDLL != undefined) {
                    this.ReferenceDLL = data.ReferenceDLL;
                }
                if ("TargetDLL" in data && data.TargetDLL != undefined) {
                    this.TargetDLL = data.TargetDLL;
                }
                if ("ProfileName" in data && data.ProfileName != undefined) {
                    this.ProfileName = data.ProfileName;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get ReferenceDLLPath() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set ReferenceDLLPath(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get TargetLocation() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set TargetLocation(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get ReferenceDLL() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set ReferenceDLL(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get TargetDLL() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set TargetDLL(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get ProfileName() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set ProfileName(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            ReferenceDLLPath?: string;
            TargetLocation?: string;
            ReferenceDLL?: Uint8Array;
            TargetDLL?: Uint8Array;
            ProfileName?: string;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new DllHijackReq({});
            if (data.ReferenceDLLPath != null) {
                message.ReferenceDLLPath = data.ReferenceDLLPath;
            }
            if (data.TargetLocation != null) {
                message.TargetLocation = data.TargetLocation;
            }
            if (data.ReferenceDLL != null) {
                message.ReferenceDLL = data.ReferenceDLL;
            }
            if (data.TargetDLL != null) {
                message.TargetDLL = data.TargetDLL;
            }
            if (data.ProfileName != null) {
                message.ProfileName = data.ProfileName;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                ReferenceDLLPath?: string;
                TargetLocation?: string;
                ReferenceDLL?: Uint8Array;
                TargetDLL?: Uint8Array;
                ProfileName?: string;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.ReferenceDLLPath != null) {
                data.ReferenceDLLPath = this.ReferenceDLLPath;
            }
            if (this.TargetLocation != null) {
                data.TargetLocation = this.TargetLocation;
            }
            if (this.ReferenceDLL != null) {
                data.ReferenceDLL = this.ReferenceDLL;
            }
            if (this.TargetDLL != null) {
                data.TargetDLL = this.TargetDLL;
            }
            if (this.ProfileName != null) {
                data.ProfileName = this.ProfileName;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.ReferenceDLLPath === "string" && this.ReferenceDLLPath.length)
                writer.writeString(1, this.ReferenceDLLPath);
            if (typeof this.TargetLocation === "string" && this.TargetLocation.length)
                writer.writeString(2, this.TargetLocation);
            if (this.ReferenceDLL !== undefined)
                writer.writeBytes(3, this.ReferenceDLL);
            if (this.TargetDLL !== undefined)
                writer.writeBytes(4, this.TargetDLL);
            if (typeof this.ProfileName === "string" && this.ProfileName.length)
                writer.writeString(5, this.ProfileName);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DllHijackReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DllHijackReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ReferenceDLLPath = reader.readString();
                        break;
                    case 2:
                        message.TargetLocation = reader.readString();
                        break;
                    case 3:
                        message.ReferenceDLL = reader.readBytes();
                        break;
                    case 4:
                        message.TargetDLL = reader.readBytes();
                        break;
                    case 5:
                        message.ProfileName = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DllHijackReq {
            return DllHijackReq.deserialize(bytes);
        }
    }
    export class DllHijack extends pb_1.Message {
        constructor(data?: any[] | {
            Response?: dependency_1.commonpb.Response;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Response" in data && data.Response != undefined) {
                    this.Response = data.Response;
                }
            }
        }
        get Response() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Response, 9) as dependency_1.commonpb.Response;
        }
        set Response(value: dependency_1.commonpb.Response) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
        }) {
            const message = new DllHijack({});
            if (data.Response != null) {
                message.Response = dependency_1.commonpb.Response.fromObject(data.Response);
            }
            return message;
        }
        toObject() {
            const data: {
                Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
            } = {};
            if (this.Response != null) {
                data.Response = this.Response.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Response !== undefined)
                writer.writeMessage(9, this.Response, () => this.Response.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DllHijack {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DllHijack();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 9:
                        reader.readMessage(message.Response, () => message.Response = dependency_1.commonpb.Response.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DllHijack {
            return DllHijack.deserialize(bytes);
        }
    }
    export class ShellcodeEncodeReq extends pb_1.Message {
        constructor(data?: any[] | {
            Encoder?: ShellcodeEncoder;
            Architecture?: string;
            Iterations?: number;
            BadChars?: Uint8Array;
            Data?: Uint8Array;
            Request?: dependency_1.commonpb.Request;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Encoder" in data && data.Encoder != undefined) {
                    this.Encoder = data.Encoder;
                }
                if ("Architecture" in data && data.Architecture != undefined) {
                    this.Architecture = data.Architecture;
                }
                if ("Iterations" in data && data.Iterations != undefined) {
                    this.Iterations = data.Iterations;
                }
                if ("BadChars" in data && data.BadChars != undefined) {
                    this.BadChars = data.BadChars;
                }
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
                if ("Request" in data && data.Request != undefined) {
                    this.Request = data.Request;
                }
            }
        }
        get Encoder() {
            return pb_1.Message.getField(this, 1) as ShellcodeEncoder;
        }
        set Encoder(value: ShellcodeEncoder) {
            pb_1.Message.setField(this, 1, value);
        }
        get Architecture() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set Architecture(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Iterations() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set Iterations(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get BadChars() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set BadChars(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get Data() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get Request() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Request, 9) as dependency_1.commonpb.Request;
        }
        set Request(value: dependency_1.commonpb.Request) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Encoder?: ShellcodeEncoder;
            Architecture?: string;
            Iterations?: number;
            BadChars?: Uint8Array;
            Data?: Uint8Array;
            Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
        }) {
            const message = new ShellcodeEncodeReq({});
            if (data.Encoder != null) {
                message.Encoder = data.Encoder;
            }
            if (data.Architecture != null) {
                message.Architecture = data.Architecture;
            }
            if (data.Iterations != null) {
                message.Iterations = data.Iterations;
            }
            if (data.BadChars != null) {
                message.BadChars = data.BadChars;
            }
            if (data.Data != null) {
                message.Data = data.Data;
            }
            if (data.Request != null) {
                message.Request = dependency_1.commonpb.Request.fromObject(data.Request);
            }
            return message;
        }
        toObject() {
            const data: {
                Encoder?: ShellcodeEncoder;
                Architecture?: string;
                Iterations?: number;
                BadChars?: Uint8Array;
                Data?: Uint8Array;
                Request?: ReturnType<typeof dependency_1.commonpb.Request.prototype.toObject>;
            } = {};
            if (this.Encoder != null) {
                data.Encoder = this.Encoder;
            }
            if (this.Architecture != null) {
                data.Architecture = this.Architecture;
            }
            if (this.Iterations != null) {
                data.Iterations = this.Iterations;
            }
            if (this.BadChars != null) {
                data.BadChars = this.BadChars;
            }
            if (this.Data != null) {
                data.Data = this.Data;
            }
            if (this.Request != null) {
                data.Request = this.Request.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Encoder !== undefined)
                writer.writeEnum(1, this.Encoder);
            if (typeof this.Architecture === "string" && this.Architecture.length)
                writer.writeString(2, this.Architecture);
            if (this.Iterations !== undefined)
                writer.writeUint32(3, this.Iterations);
            if (this.BadChars !== undefined)
                writer.writeBytes(4, this.BadChars);
            if (this.Data !== undefined)
                writer.writeBytes(8, this.Data);
            if (this.Request !== undefined)
                writer.writeMessage(9, this.Request, () => this.Request.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShellcodeEncodeReq {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShellcodeEncodeReq();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Encoder = reader.readEnum();
                        break;
                    case 2:
                        message.Architecture = reader.readString();
                        break;
                    case 3:
                        message.Iterations = reader.readUint32();
                        break;
                    case 4:
                        message.BadChars = reader.readBytes();
                        break;
                    case 8:
                        message.Data = reader.readBytes();
                        break;
                    case 9:
                        reader.readMessage(message.Request, () => message.Request = dependency_1.commonpb.Request.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShellcodeEncodeReq {
            return ShellcodeEncodeReq.deserialize(bytes);
        }
    }
    export class ShellcodeEncode extends pb_1.Message {
        constructor(data?: any[] | {
            Data?: Uint8Array;
            Response?: dependency_1.commonpb.Response;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Data" in data && data.Data != undefined) {
                    this.Data = data.Data;
                }
                if ("Response" in data && data.Response != undefined) {
                    this.Response = data.Response;
                }
            }
        }
        get Data() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set Data(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get Response() {
            return pb_1.Message.getWrapperField(this, dependency_1.commonpb.Response, 9) as dependency_1.commonpb.Response;
        }
        set Response(value: dependency_1.commonpb.Response) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        static fromObject(data: {
            Data?: Uint8Array;
            Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
        }) {
            const message = new ShellcodeEncode({});
            if (data.Data != null) {
                message.Data = data.Data;
            }
            if (data.Response != null) {
                message.Response = dependency_1.commonpb.Response.fromObject(data.Response);
            }
            return message;
        }
        toObject() {
            const data: {
                Data?: Uint8Array;
                Response?: ReturnType<typeof dependency_1.commonpb.Response.prototype.toObject>;
            } = {};
            if (this.Data != null) {
                data.Data = this.Data;
            }
            if (this.Response != null) {
                data.Response = this.Response.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Data !== undefined)
                writer.writeBytes(8, this.Data);
            if (this.Response !== undefined)
                writer.writeMessage(9, this.Response, () => this.Response.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShellcodeEncode {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShellcodeEncode();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 8:
                        message.Data = reader.readBytes();
                        break;
                    case 9:
                        reader.readMessage(message.Response, () => message.Response = dependency_1.commonpb.Response.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShellcodeEncode {
            return ShellcodeEncode.deserialize(bytes);
        }
    }
    export class ShellcodeEncoderMap extends pb_1.Message {
        constructor(data?: any[] | {
            Encoders?: Map<string, ShellcodeEncoder>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Encoders" in data && data.Encoders != undefined) {
                    this.Encoders = data.Encoders;
                }
            }
            if (!this.Encoders)
                this.Encoders = new Map();
        }
        get Encoders() {
            return pb_1.Message.getField(this, 1) as any as Map<string, ShellcodeEncoder>;
        }
        set Encoders(value: Map<string, ShellcodeEncoder>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            Encoders?: {
                [key: string]: ShellcodeEncoder;
            };
        }) {
            const message = new ShellcodeEncoderMap({});
            if (typeof data.Encoders == "object") {
                message.Encoders = new Map(Object.entries(data.Encoders));
            }
            return message;
        }
        toObject() {
            const data: {
                Encoders?: {
                    [key: string]: ShellcodeEncoder;
                };
            } = {};
            if (this.Encoders.size > 0) {
                data.Encoders = Object.fromEntries(this.Encoders);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.Encoders) {
                writer.writeMessage(1, this.Encoders, () => {
                    writer.writeString(1, key);
                    writer.writeEnum(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShellcodeEncoderMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShellcodeEncoderMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Encoders as any, reader, reader.readString, reader.readEnum));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShellcodeEncoderMap {
            return ShellcodeEncoderMap.deserialize(bytes);
        }
    }
}
